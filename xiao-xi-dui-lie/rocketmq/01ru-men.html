<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>01-入门 | PYY在线笔记</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/study/img/logo.png">
    <meta name="description" content="PYY在线笔记">
    
    <link rel="preload" href="/study/assets/css/0.styles.f503b9f0.css" as="style"><link rel="preload" href="/study/assets/js/app.dc60e210.js" as="script"><link rel="preload" href="/study/assets/js/6.fceef279.js" as="script"><link rel="preload" href="/study/assets/js/10.7ed69d34.js" as="script"><link rel="prefetch" href="/study/assets/js/11.9448c32e.js"><link rel="prefetch" href="/study/assets/js/12.86c493c7.js"><link rel="prefetch" href="/study/assets/js/13.9ed58975.js"><link rel="prefetch" href="/study/assets/js/14.48e59348.js"><link rel="prefetch" href="/study/assets/js/15.b5bdf29c.js"><link rel="prefetch" href="/study/assets/js/16.7e65e129.js"><link rel="prefetch" href="/study/assets/js/17.d21d2357.js"><link rel="prefetch" href="/study/assets/js/18.ff6a09ec.js"><link rel="prefetch" href="/study/assets/js/19.4dd597a5.js"><link rel="prefetch" href="/study/assets/js/2.6082ecbd.js"><link rel="prefetch" href="/study/assets/js/20.13424f64.js"><link rel="prefetch" href="/study/assets/js/21.d0a93e41.js"><link rel="prefetch" href="/study/assets/js/22.3157d1d1.js"><link rel="prefetch" href="/study/assets/js/23.bf30424e.js"><link rel="prefetch" href="/study/assets/js/24.6e0cd257.js"><link rel="prefetch" href="/study/assets/js/25.85fbb512.js"><link rel="prefetch" href="/study/assets/js/26.c54e0c14.js"><link rel="prefetch" href="/study/assets/js/27.6da488a3.js"><link rel="prefetch" href="/study/assets/js/28.321038ce.js"><link rel="prefetch" href="/study/assets/js/29.3fe454c4.js"><link rel="prefetch" href="/study/assets/js/3.e7c144f8.js"><link rel="prefetch" href="/study/assets/js/30.2c2ed4ad.js"><link rel="prefetch" href="/study/assets/js/31.99fb9619.js"><link rel="prefetch" href="/study/assets/js/32.5aea4bba.js"><link rel="prefetch" href="/study/assets/js/33.8ed67f2e.js"><link rel="prefetch" href="/study/assets/js/34.4eb2a764.js"><link rel="prefetch" href="/study/assets/js/35.32c83c52.js"><link rel="prefetch" href="/study/assets/js/36.0e7c4410.js"><link rel="prefetch" href="/study/assets/js/37.029a3bab.js"><link rel="prefetch" href="/study/assets/js/38.9404c1e2.js"><link rel="prefetch" href="/study/assets/js/39.99a331b6.js"><link rel="prefetch" href="/study/assets/js/4.5e539c6c.js"><link rel="prefetch" href="/study/assets/js/40.68a12f82.js"><link rel="prefetch" href="/study/assets/js/41.f802eb8f.js"><link rel="prefetch" href="/study/assets/js/42.9353144d.js"><link rel="prefetch" href="/study/assets/js/43.58a525e4.js"><link rel="prefetch" href="/study/assets/js/44.d327c357.js"><link rel="prefetch" href="/study/assets/js/45.54dc5bdd.js"><link rel="prefetch" href="/study/assets/js/46.97eb4353.js"><link rel="prefetch" href="/study/assets/js/47.d0f5dd26.js"><link rel="prefetch" href="/study/assets/js/48.c71e0efd.js"><link rel="prefetch" href="/study/assets/js/49.c4bf96d9.js"><link rel="prefetch" href="/study/assets/js/5.49f21cfc.js"><link rel="prefetch" href="/study/assets/js/50.a9f40bc0.js"><link rel="prefetch" href="/study/assets/js/51.cb5601bb.js"><link rel="prefetch" href="/study/assets/js/52.f4b73d57.js"><link rel="prefetch" href="/study/assets/js/7.e9fa99bf.js"><link rel="prefetch" href="/study/assets/js/8.60f08f23.js"><link rel="prefetch" href="/study/assets/js/9.1ebd5ad9.js">
    <link rel="stylesheet" href="/study/assets/css/0.styles.f503b9f0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/study/" class="home-link router-link-active"><img src="/study/img/logo.png" alt="PYY在线笔记" class="logo"> <span class="site-name can-hide">PYY在线笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/study/技术方案/" class="nav-link">
  技术方案
</a></div><div class="nav-item"><a href="/study/Java技术栈/" class="nav-link">
  Java技术栈
</a></div><div class="nav-item"><a href="/study/分布式/" class="nav-link">
  分布式
</a></div><div class="nav-item"><a href="/study/大数据/" class="nav-link">
  大数据
</a></div><div class="nav-item"><a href="/study/消息队列/" class="nav-link">
  消息队列
</a></div><div class="nav-item"><a href="/study/数据结构和算法/" class="nav-link">
  数据结构和算法
</a></div><div class="nav-item"><a href="/study/k8s/" class="nav-link">
  k8s
</a></div><div class="nav-item"><a href="/study/ServiceMesh/" class="nav-link">
  ServiceMesh
</a></div><div class="nav-item"><a href="/study/DevOps/" class="nav-link">
  DevOps
</a></div><div class="nav-item"><a href="/study/总结/" class="nav-link">
  总结
</a></div><div class="nav-item"><a href="https://www.jianshu.com/u/af08f637aff8" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/study/技术方案/" class="nav-link">
  技术方案
</a></div><div class="nav-item"><a href="/study/Java技术栈/" class="nav-link">
  Java技术栈
</a></div><div class="nav-item"><a href="/study/分布式/" class="nav-link">
  分布式
</a></div><div class="nav-item"><a href="/study/大数据/" class="nav-link">
  大数据
</a></div><div class="nav-item"><a href="/study/消息队列/" class="nav-link">
  消息队列
</a></div><div class="nav-item"><a href="/study/数据结构和算法/" class="nav-link">
  数据结构和算法
</a></div><div class="nav-item"><a href="/study/k8s/" class="nav-link">
  k8s
</a></div><div class="nav-item"><a href="/study/ServiceMesh/" class="nav-link">
  ServiceMesh
</a></div><div class="nav-item"><a href="/study/DevOps/" class="nav-link">
  DevOps
</a></div><div class="nav-item"><a href="/study/总结/" class="nav-link">
  总结
</a></div><div class="nav-item"><a href="https://www.jianshu.com/u/af08f637aff8" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Dev Ops</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java技术栈</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Service Mesh</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>K 8 S</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>分布式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>大数据</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>总结</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>技术方案</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构和算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>消息队列</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/xiao-xi-dui-lie/" aria-current="page" class="sidebar-link">介绍</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Kafka</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>Rocket MQ</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html" aria-current="page" class="active sidebar-link">01-入门</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#rocketmq-专业术语" class="sidebar-link">RocketMQ 专业术语</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#topic的存储" class="sidebar-link">Topic的存储</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#部署模型" class="sidebar-link">部署模型</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#详解broker" class="sidebar-link">详解Broker</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#producer-生产者" class="sidebar-link">Producer(生产者)</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#consumer-消费者" class="sidebar-link">Consumer (消费者)</a></li></ul></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#集群部署方式" class="sidebar-link">集群部署方式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#单-master-模式" class="sidebar-link">单 Master 模式</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#多master模式" class="sidebar-link">多Master模式</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#多-master-多-slave-异步复制模式" class="sidebar-link">多 master 多 slave 异步复制模式</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#多master-多-slave-同步双写模式" class="sidebar-link">多Master 多 Slave 同步双写模式</a></li></ul></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#双主双从集群搭建" class="sidebar-link">双主双从集群搭建</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#总体架构" class="sidebar-link">总体架构</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#集群工作流程" class="sidebar-link">集群工作流程</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#服务器环境" class="sidebar-link">服务器环境</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#防火墙配置" class="sidebar-link">防火墙配置</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#环境变量配置" class="sidebar-link">环境变量配置</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#创建消息存储路径" class="sidebar-link">创建消息存储路径</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#broker配置文件" class="sidebar-link">broker配置文件</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#修改启动脚本文件" class="sidebar-link">修改启动脚本文件</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#服务启动" class="sidebar-link">服务启动</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#查看进程状态" class="sidebar-link">查看进程状态</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#查看日志" class="sidebar-link">查看日志</a></li></ul></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#rocketmq集群监控平台搭建" class="sidebar-link">RocketMQ集群监控平台搭建</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#概述" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#下载并编译打包" class="sidebar-link">下载并编译打包</a></li></ul></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#消息发送样例" class="sidebar-link">消息发送样例</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#基本样例" class="sidebar-link">基本样例</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#普通消息" class="sidebar-link">普通消息</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#有序消息" class="sidebar-link">有序消息</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#延时消息" class="sidebar-link">延时消息</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#批量消息" class="sidebar-link">批量消息</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#事务消息" class="sidebar-link">事务消息</a></li></ul></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#高级特性" class="sidebar-link">高级特性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#消息过滤" class="sidebar-link">消息过滤</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#订阅关系一致性" class="sidebar-link">订阅关系一致性</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#消息重试" class="sidebar-link">消息重试</a></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#消息幂等" class="sidebar-link">消息幂等</a></li></ul></li><li class="sidebar-sub-header"><a href="/study/xiao-xi-dui-lie/rocketmq/01ru-men.html#高级功能" class="sidebar-link">高级功能</a></li></ul></li><li><a href="/study/xiao-xi-dui-lie/rocketmq/02gao-ji-te-xing.html" class="sidebar-link">02-高级特性</a></li><li><a href="/study/xiao-xi-dui-lie/rocketmq/03yuan-ma-fen-xi.html" class="sidebar-link">03-源码分析</a></li><li><a href="/study/xiao-xi-dui-lie/rocketmq/04an-li-jie-shao.html" class="sidebar-link">04-案例介绍</a></li></ul></section></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_01-入门"><a href="#_01-入门" class="header-anchor">#</a> 01-入门</h1> <h2 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h2> <p>RocketMQ一个纯Java、分布式、队列模型的开源消息中间件，前身是MetaQ，是阿里研发的一个队列模型的消息中间件，后开源给apache基金会成为了apache的顶级开源项目，具有高性能、高可靠、高实时、分布式特点。</p> <h2 id="rocketmq-专业术语"><a href="#rocketmq-专业术语" class="header-anchor">#</a> RocketMQ 专业术语</h2> <p>先讲专业术语的含义，后面会画流程图来更好的去理解它们。</p> <ul><li><p>Producer</p> <p>消息生产者，位于用户的进程内，<code>Producer通过NameServer获取所有Broker的路由信息</code>，根据负载均衡策略选择将消息发到哪个Broker，然后调用Broker接口提交消息。</p></li> <li><p>Producer Group</p> <p>生产者组，简单来说就是多个发送同一类消息的生产者称之为一个生产者组。</p></li> <li><p>Consumer</p> <p>消息消费者，位于用户进程内。Consumer通过NameServer获取所有broker的路由信息后，向Broker发送请求来获取消息数据。Consumer可以以两种模式启动，<strong>广播（Broadcast）和集群（Cluster）</strong>，<strong>广播模式下，一条消息会发送给所有Consumer，集群模式下消息只会发送给一个Consumer</strong>。</p></li> <li><p>Consumer Group</p> <p>消费者组，和生产者类似，消费同一类消息的多个 Consumer 实例组成一个消费者组。</p></li> <li><p>Topic</p> <p>Topic用于将消息按主题做划分，<strong>Producer将消息发往指定的Topic，Consumer订阅该Topic就可以收到这条消息</strong>。Topic跟发送方和消费方都没有强关联关系，发送方可以同时往多个Topic投放消息，消费方也可以订阅多个Topic的消息。在RocketMQ中，<strong>Topic是一个上逻辑概念。消息存储不会按Topic分开</strong>。</p></li> <li><p>Message</p> <p>代表一条消息，使用<code>MessageId</code>唯一识别，用户在发送时可以设置messageKey，便于之后查询和跟踪。一个 Message 必须指定 Topic，相当于寄信的地址。Message 还有一个可选的 Tag 设置，以便消费端可以基于 Tag 进行过滤消息。也可以添加额外的键值对，例如你需要一个业务 key 来查找 Broker 上的消息，方便在开发过程中诊断问题。</p></li> <li><p>Tag</p> <p>标签可以被认为是对 Topic 进一步细化。一般在相同业务模块中通过引入标签来标记不同用途的消息。</p></li> <li><p>Broker</p> <p>Broker是RocketMQ的核心模块，<code>负责接收并存储消息</code>，同时提供Push/Pull接口来将消息发送给Consumer。Consumer可选择从Master或者Slave读取数据。多个主/从组成Broker集群，集群内的Master节点之间不做数据交互。Broker同时提供消息查询的功能，可以通过MessageID和MessageKey来查询消息。Borker会将自己的Topic配置信息实时同步到NameServer。</p></li> <li><p>Queue</p> <p><strong>Topic和Queue是1对多的关系</strong>，<strong>一个Topic下可以包含多个Queue</strong>，主要用于负载均衡。发送消息时，用户只指定Topic，Producer会根据Topic的路由信息选择具体发到哪个Queue上。Consumer订阅消息时，会根据负载均衡策略决定订阅哪些Queue的消息。</p></li> <li><p>Offset</p> <p>RocketMQ在存储消息时会为每个Topic下的每个Queue生成一个消息的索引文件，每个Queue都对应一个Offset<strong>记录当前Queue中消息条数</strong>。</p></li> <li><p>NameServer</p> <p>NameServer可以看作是RocketMQ的注册中心，它管理两部分数据：集群的Topic-Queue的路由配置；Broker的实时配置信息。其它模块通过Nameserv提供的接口获取最新的Topic配置和路由信息。</p> <ul><li><code>Producer/Consumer</code> ：通过查询接口获取Topic对应的Broker的地址信息</li> <li><code>Broker</code> ： 注册配置信息到NameServer， 实时更新Topic信息到NameServer</li></ul></li></ul> <p>我们由简单到复杂的来理解，它的一些核心概念</p> <p><img src="/study/assets/img/1090617-20190626173010056-1457807155.f89c5b5b.jpg" alt="img"></p> <p>这个图很好理解，消息先发到Topic，然后消费者去Topic拿消息。只是Topic在这里只是个概念，那它到底是怎么存储消息数据的呢，这里就要引入Broker概念。</p> <h3 id="topic的存储"><a href="#topic的存储" class="header-anchor">#</a> Topic的存储</h3> <p>Topic是一个逻辑上的概念，实际上Message是在每个Broker上以Queue的形式记录。</p> <blockquote><p><img src="/study/assets/img/1090617-20190626173042073-147043337.0b6b109c.jpg" alt="img"></p></blockquote> <p>从上面的图片可以总结下几条结论。</p> <blockquote><ol><li><p>消费者发送的Message会在Broker中的Queue队列中记录。</p></li> <li><p>一个Topic的数据可能会存在多个Broker中。</p></li> <li><p>一个Broker存在多个Queue。</p></li> <li><p>单个的Queue也可能存储多个Topic的消息。</p></li></ol></blockquote> <p>也就是说每个Topic在Broker上会划分成几个逻辑队列，每个逻辑队列保存一部分消息数据，但是保存的消息数据实际上不是真正的消息数据，而是指向commit log的消息索引。</p> <p><code>Queue不是真正存储Message的地方，真正存储Message的地方是在CommitLog</code>。</p> <p><img src="/study/assets/img/1090617-20190626235211016-2054524747.e5ec3261.png" alt="img"></p> <p>左边的是CommitLog。这个是真正存储消息的地方。RocketMQ所有生产者的消息都是往这一个地方存的。</p> <p>右边是ConsumeQueue。这是一个逻辑队列。和上文中Topic下的Queue是一一对应的。消费者是直接和ConsumeQueue打交道。ConsumeQueue记录了消费位点，这个消费位点关联了commitlog的位置。所以即使ConsumeQueue出问题，只要commitlog还在，消息就没丢，可以恢复出来。还可以通过修改消费位点来重放或跳过一些消息。</p> <h3 id="部署模型"><a href="#部署模型" class="header-anchor">#</a> 部署模型</h3> <p>在部署RocketMQ时，会部署两种角色。NameServer和Broker。如图（盗图）</p> <p><img src="/study/assets/img/1090617-20190626233829426-1023022108.e3953a24.png" alt="img"></p> <p>针对这张图做个说明</p> <div class="language- extra-class"><pre class="language-text"><code>1、Product和consumer集群部署，是你开发的项目进行集群部署。
2、Broker 集群部署是为了高可用，因为Broker是真正存储Message的地方，集群部署是为了避免一台挂掉，导致整个项目KO.
</code></pre></div><p>那Name SerVer是做什么用呢，它和Product、Consumer、Broker之前存在怎样的关系呢？</p> <p>先简单概括Name Server的特点</p> <div class="language- extra-class"><pre class="language-text"><code>1、Name Server是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。
2、每个Broker与Name Server集群中的所有节点建立长连接，定时注册Topic信息到所有Name Server。
3、Producer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息。
4、Consumer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息。
</code></pre></div><p>这里面最核心的是<code>每个Broker与Name Server集群中的所有节点建立长连接</code>这样做好处多多。</p> <div class="language- extra-class"><pre class="language-text"><code>1、这样可以使Name Server之间可以没有任何关联，因为它们绑定的Broker是一致的。
2、作为Producer或者Consumer可以绑定任何一个Name Server 因为它们都是一样的。
</code></pre></div><h3 id="详解broker"><a href="#详解broker" class="header-anchor">#</a> 详解Broker</h3> <ul><li><p><strong>Broker与Name Server关系</strong></p> <p><strong>1）连接</strong> 单个Broker和所有Name Server保持长连接。</p> <p><strong>2）心跳</strong></p> <p><strong>心跳间隔</strong>：每隔<strong>30秒</strong>向所有NameServer发送心跳，心跳包含了自身的Topic配置信息。</p> <p><strong>心跳超时</strong>：NameServer每隔<strong>10秒</strong>，扫描所有还存活的Broker连接，若某个连接2分钟内没有发送心跳数据，则断开连接。</p> <p><strong>3）断开</strong>：当Broker挂掉；NameServer会根据心跳超时主动关闭连接,一旦连接断开，会更新Topic与队列的对应关系，但不会通知生产者和消费者。</p></li> <li><p><strong>负载均衡</strong></p> <p>一个Topic分布在多个Broker上，一个Broker可以配置多个Topic，它们是多对多的关系。
如果某个Topic消息量很大，应该给它多配置几个Queue，并且尽量多分布在不同Broker上，减轻某个Broker的压力。</p></li> <li><p><strong>可用性</strong></p> <p>由于消息分布在各个Broker上，一旦某个Broker宕机，则该Broker上的消息读写都会受到影响。</p> <p>所以RocketMQ提供了Master/Slave的结构，Salve定时从Master同步数据，如果Master宕机，则Slave提供消费服务，但是不能写入消息，此过程对应用透明，由RocketMQ内部解决。
有两个关键点：
<code>思考1</code>一旦某个broker master宕机，生产者和消费者多久才能发现？</p> <p>受限于Rocketmq的网络连接机制，默认情况下最多需要<strong>30秒</strong>，因为消费者每隔30秒从nameserver获取所有topic的最新队列情况，这意味着某个broker如果宕机，客户端最多要30秒才能感知。</p> <p><code>思考2</code> master恢复恢复后，消息能否恢复。
消费者得到Master宕机通知后，转向Slave消费，但是Slave不能保证Master的消息100%都同步过来了，因此会有少量的消息丢失。但是消息最终不会丢的，一旦Master恢复，未同步过去的消息会被消费掉。</p></li></ul> <h3 id="producer-生产者"><a href="#producer-生产者" class="header-anchor">#</a> Producer(生产者)</h3> <ul><li><p>Producer与Name Server关系</p> <ul><li><strong>连接</strong> 单个Producer和一台NameServer保持长连接，如果该NameServer挂掉，生产者会自动连接下一个NameServer，直到有可用连接为止，并能自动重连。</li> <li><strong>轮询时间</strong> 默认情况下，生产者每隔30秒从NameServer获取所有Topic的最新队列情况，这意味着某个Broker如果宕机，生产者最多要30秒才能感知，在此期间，
发往该broker的消息发送失败。</li> <li><strong>心跳</strong> 与nameserver没有心跳</li></ul></li> <li><p>与broker关系</p> <p>连接 单个生产者和该生产者关联的所有broker保持长连接。</p></li></ul> <h3 id="consumer-消费者"><a href="#consumer-消费者" class="header-anchor">#</a> Consumer (消费者)</h3> <ul><li><p>Consumer与Name Server关系</p> <ul><li><strong>连接</strong> : 单个Consumer和一台NameServer保持长连接，如果该NameServer挂掉，消费者会自动连接下一个NameServer，直到有可用连接为止，并能自动重连。</li> <li><strong>心跳</strong>: 与NameServer没有心跳</li> <li><strong>轮询时间</strong> : 默认情况下，消费者每隔<strong>30秒</strong>从NameServer获取所有Topic的最新队列情况，这意味着某个Broker如果宕机，客户端最多要30秒才能感知。</li></ul></li> <li><p>Consumer与Broker关系
连接 : 单个消费者和该消费者关联的所有broker保持长连接。</p></li> <li><p>负载均衡</p> <p>集群消费模式下，一个消费者集群多台机器共同消费一个Topic的多个队列，一个队列只会被一个消费者消费。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。</p></li></ul> <h2 id="集群部署方式"><a href="#集群部署方式" class="header-anchor">#</a> 集群部署方式</h2> <h3 id="单-master-模式"><a href="#单-master-模式" class="header-anchor">#</a> 单 Master 模式</h3> <p>只有一个 Master节点</p> <ul><li><p>优点：配置简单，方便部署</p></li> <li><p>缺点：这种方式风险较大，一旦Broker重启或者宕机时，会导致整个服务不可用，不建议线上环境使用</p></li></ul> <h3 id="多master模式"><a href="#多master模式" class="header-anchor">#</a> 多Master模式</h3> <p>多个 master 节点组成集群，单个 master 节点宕机或者重启对应用没有影响。</p> <ul><li><p>优点：所有模式中性能最高</p></li> <li><p>缺点：单个 master 节点宕机期间，未被消费的消息在节点恢复之前不可用，消息的实时性就受到影响。</p></li></ul> <blockquote><p>注意：使用同步刷盘可以保证消息不丢失，同时 Topic 相对应的 queue 应该分布在集群中各个节点，而不是只在某各节点上，否则，该节点宕机会对订阅该 topic 的应用造成影响。</p></blockquote> <h3 id="多-master-多-slave-异步复制模式"><a href="#多-master-多-slave-异步复制模式" class="header-anchor">#</a> 多 master 多 slave 异步复制模式</h3> <p>在多 master 模式的基础上，每个 master 节点都有至少一个对应的 slave。master节点可读可写，但是 slave 只能读不能写，类似于 mysql 的主备模式。</p> <ul><li>优点： 在 master 宕机时，消费者可以从 slave 读取消息，消息的实时性不会受影响，性能几乎和多 master 一样。</li> <li>缺点：使用异步复制的同步方式有可能会有消息丢失的问题。</li></ul> <h3 id="多master-多-slave-同步双写模式"><a href="#多master-多-slave-同步双写模式" class="header-anchor">#</a> 多Master 多 Slave 同步双写模式</h3> <p>同多 master 多 slave 异步复制模式类似，区别在于 master 和 slave 之间的数据同步方式。</p> <ul><li><p>优点：同步双写的同步模式能保证数据不丢失。</p></li> <li><p>缺点：发送单个消息 RT 会略长，性能相比异步复制低10%左右。发送单个消息的<code>RT</code>会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</p></li></ul> <h2 id="双主双从集群搭建"><a href="#双主双从集群搭建" class="header-anchor">#</a> 双主双从集群搭建</h2> <h3 id="总体架构"><a href="#总体架构" class="header-anchor">#</a> 总体架构</h3> <p>消息高可用采用2<code>master</code>-2<code>slave</code>（同步双写）方式</p> <p><img src="/study/assets/img/1580998-20200609183942488-1130690477.5ed4beac.png" alt="img"></p> <h3 id="集群工作流程"><a href="#集群工作流程" class="header-anchor">#</a> 集群工作流程</h3> <ol><li>启动<code>NameServer</code>，<code>NameServer</code>起来后监听端口，等待<code>Broker</code>、<code>Producer</code>、<code>Consumer</code>连上来，相当于一个路由控制中心。</li> <li><code>Broker</code>启动，跟所有的<code>NameServer</code>保持长连接，定时发送心跳包。心跳包中包含当前<code>Broker</code>信息(<code>IP</code>+端口等)以及存储所有<code>Topic</code>信息。注册成功后，<code>NameServer</code>集群中就有<code>Topic</code>跟<code>Broker</code>的映射关系。</li> <li>收发消息前，先创建<code>Topic</code>，创建<code>Topic</code>时需要指定该<code>Topic</code>要存储在哪些<code>Broker</code>上，也可以在发送消息时自动创建<code>Topic</code>。</li> <li><code>Producer</code>发送消息，启动时先跟<code>NameServer</code>集群中的其中一台建立长连接，并从<code>NameServer</code>中获取当前发送的<code>Topic</code>存在哪些<code>Broker</code>上，轮询从队列列表中选择一个队列，然后与队列所在的<code>Broker</code>建立长连接从而向<code>Broker</code>发消息。</li> <li><code>Consumer</code>跟<code>Producer</code>类似，跟其中一台<code>NameServer</code>建立长连接，获取当前订阅<code>Topic</code>存在哪些<code>Broker</code>上，然后直接跟<code>Broker</code>建立连接通道，开始消费消息。</li></ol> <h3 id="服务器环境"><a href="#服务器环境" class="header-anchor">#</a> 服务器环境</h3> <p>选择两个或四个服务器（根据实际情况选择）</p> <table><thead><tr><th><strong>序号</strong></th> <th><strong>IP</strong></th> <th><strong>角色</strong></th> <th><strong>架构模式</strong></th></tr></thead> <tbody><tr><td>1</td> <td>192.168.2.12</td> <td>nameserver、brokerserver</td> <td>Master1、Slave2</td></tr> <tr><td>2</td> <td>192.168.2.13</td> <td>nameserver、brokerserver</td> <td>Master2、Slave1</td></tr></tbody></table> <p><code>Host</code>添加信息</p> <div class="language- extra-class"><pre class="language-text"><code>vim /etc/hosts
</code></pre></div><p>配置如下:</p> <div class="language- extra-class"><pre class="language-text"><code># nameserver
192.168.2.12 rocketmq-nameserver1
192.168.2.13 rocketmq-nameserver2
# broker
192.168.2.12 rocketmq-master1
192.168.2.12 rocketmq-slave2
192.168.2.13 rocketmq-master2
192.168.2.13 rocketmq-slave1
</code></pre></div><p>配置完成后, 重启网卡</p> <div class="language- extra-class"><pre class="language-text"><code>systemctl restart network
</code></pre></div><h3 id="防火墙配置"><a href="#防火墙配置" class="header-anchor">#</a> 防火墙配置</h3> <p>宿主机需要远程访问虚拟机的<code>rocketmq</code>服务和<code>web</code>服务，需要开放相关的端口号，简单粗暴的方式是直接关闭防火墙</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 关闭防火墙</span>
systemctl stop firewalld.service 
<span class="token comment"># 查看防火墙的状态</span>
firewall-cmd --state 
<span class="token comment"># 禁止firewall开机启动</span>
systemctl disable firewalld.service
</code></pre></div><p><a href="https://img2020.cnblogs.com/blog/1580998/202006/1580998-20200609184046749-1812798366.png" target="_blank" rel="noopener noreferrer"><img src="https://img2020.cnblogs.com/blog/1580998/202006/1580998-20200609184046749-1812798366.png" alt="img"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>或者为了安全，只开放特定的端口号，<code>RocketMQ</code>默认使用3个端口：9876 、10911 、11011 。如果防火墙没有关闭的话，那么防火墙就必须开放这些端口：</p> <ul><li><code>nameserver</code> 默认使用 9876 端口</li> <li><code>master</code> 默认使用 10911 端口</li> <li><code>slave</code> 默认使用11011 端口</li></ul> <p>执行以下命令：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 开放name server默认端口</span>
firewall-cmd --remove-port<span class="token operator">=</span><span class="token number">9876</span>/tcp --permanent
<span class="token comment"># 开放master默认端口</span>
firewall-cmd --remove-port<span class="token operator">=</span><span class="token number">10911</span>/tcp --permanent
<span class="token comment"># 开放slave默认端口 (当前集群模式可不开启)</span>
firewall-cmd --remove-port<span class="token operator">=</span><span class="token number">11011</span>/tcp --permanent 
<span class="token comment"># 重启防火墙</span>
firewall-cmd --reload
</code></pre></div><h3 id="环境变量配置"><a href="#环境变量配置" class="header-anchor">#</a> 环境变量配置</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">vim</span> /etc/profile
</code></pre></div><p>在<code>profile</code>文件的末尾加入如下命令</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">#set rocketmq 该目录为rocketmq二进制包解压目录</span>
<span class="token assign-left variable">ROCKETMQ_HOME</span><span class="token operator">=</span>/usr/local/rocketmq
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$ROCKETMQ_HOME</span>/bin
<span class="token builtin class-name">export</span> ROCKETMQ_HOME <span class="token environment constant">PATH</span>
</code></pre></div><p>输入:wq! 保存并退出， 并使得配置立刻生效：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">source</span> /etc/profile
</code></pre></div><h3 id="创建消息存储路径"><a href="#创建消息存储路径" class="header-anchor">#</a> 创建消息存储路径</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">mkdir</span> /usr/local/rocketmq/store
<span class="token function">mkdir</span> /usr/local/rocketmq/store/commitlog
<span class="token function">mkdir</span> /usr/local/rocketmq/store/consumequeue
<span class="token function">mkdir</span> /usr/local/rocketmq/store/index
</code></pre></div><div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">mkdir</span> /usr/local/rocketmq/store-s
<span class="token function">mkdir</span> /usr/local/rocketmq/store-s/commitlog
<span class="token function">mkdir</span> /usr/local/rocketmq/store-s/consumequeue
<span class="token function">mkdir</span> /usr/local/rocketmq/store-s/index
</code></pre></div><p>注意：master 和 slave 的store 必须分开，不然会报错</p> <div class="language- extra-class"><pre class="language-text"><code>java.lang.RuntimeException: Lock failed,MQ already started
	at org.apache.rocketmq.store.DefaultMessageStore.start(DefaultMessageStore.java:214)
	at org.apache.rocketmq.broker.BrokerController.start(BrokerController.java:827)
	at org.apache.rocketmq.broker.BrokerStartup.start(BrokerStartup.java:64)
	at org.apache.rocketmq.broker.BrokerStartup.main(BrokerStartup.java:58)
</code></pre></div><h3 id="broker配置文件"><a href="#broker配置文件" class="header-anchor">#</a> <code>broker</code>配置文件</h3> <h4 id="_1-master1"><a href="#_1-master1" class="header-anchor">#</a> 1）<code>master1</code></h4> <p>服务器：<code>192.168.2.12</code></p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">vim</span> /usr/local/rocketmq/conf/2m-2s-sync/new-broker-a.properties
</code></pre></div><p>修改配置如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">#所属集群名字</span>
<span class="token assign-left variable">brokerClusterName</span><span class="token operator">=</span>rocketmq-cluster
<span class="token comment">##broker名字，名字可重复,为了管理,每个master起一个名字,他的slave同他,eg:Amaster叫broker-a,他的slave也叫broker-a</span>
<span class="token assign-left variable">brokerName</span><span class="token operator">=</span>broker-a
<span class="token comment">#0 表示 Master，&gt;0 表示 Slave</span>
<span class="token assign-left variable">brokerId</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token comment">#nameServer地址，分号分割</span>
<span class="token assign-left variable">namesrvAddr</span><span class="token operator">=</span>rocketmq-nameserver1:9876<span class="token punctuation">;</span>rocketmq-nameserver2:9876
<span class="token comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span>
<span class="token assign-left variable">defaultTopicQueueNums</span><span class="token operator">=</span><span class="token number">4</span>
<span class="token comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span>
<span class="token assign-left variable">autoCreateTopicEnable</span><span class="token operator">=</span>true
<span class="token comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span>
<span class="token assign-left variable">autoCreateSubscriptionGroup</span><span class="token operator">=</span>true
<span class="token comment">#Broker 对外服务的监听端口</span>
<span class="token assign-left variable">listenPort</span><span class="token operator">=</span><span class="token number">10911</span>
<span class="token comment">#删除文件时间点，默认凌晨 4点</span>
<span class="token assign-left variable">deleteWhen</span><span class="token operator">=</span>04
<span class="token comment">#文件保留时间，默认 48 小时</span>
<span class="token assign-left variable">fileReservedTime</span><span class="token operator">=</span><span class="token number">120</span>
<span class="token comment">#commitLog每个文件的大小默认1G</span>
<span class="token assign-left variable">mapedFileSizeCommitLog</span><span class="token operator">=</span><span class="token number">1073741824</span>
<span class="token comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span>
<span class="token assign-left variable">mapedFileSizeConsumeQueue</span><span class="token operator">=</span><span class="token number">300000</span>
<span class="token comment">#destroyMapedFileIntervalForcibly=120000</span>
<span class="token comment">#redeleteHangedFileInterval=120000</span>
<span class="token comment">#检测物理文件磁盘空间</span>
<span class="token assign-left variable">diskMaxUsedSpaceRatio</span><span class="token operator">=</span><span class="token number">88</span>
<span class="token comment">#存储路径</span>
<span class="token assign-left variable">storePathRootDir</span><span class="token operator">=</span>/usr/local/rocketmq/store
<span class="token comment">#commitLog 存储路径</span>
<span class="token assign-left variable">storePathCommitLog</span><span class="token operator">=</span>/usr/local/rocketmq/store/commitlog
<span class="token comment">#消费队列存储路径存储路径</span>
<span class="token assign-left variable">storePathConsumeQueue</span><span class="token operator">=</span>/usr/local/rocketmq/store/consumequeue
<span class="token comment">#消息索引存储路径</span>
<span class="token assign-left variable">storePathIndex</span><span class="token operator">=</span>/usr/local/rocketmq/store/index
<span class="token comment">#checkpoint 文件存储路径</span>
<span class="token assign-left variable">storeCheckpoint</span><span class="token operator">=</span>/usr/local/rocketmq/store/checkpoint
<span class="token comment">#abort 文件存储路径</span>
<span class="token assign-left variable">abortFile</span><span class="token operator">=</span>/usr/local/rocketmq/store/abort
<span class="token comment">#限制的消息大小</span>
<span class="token assign-left variable">maxMessageSize</span><span class="token operator">=</span><span class="token number">65536</span>
<span class="token comment">#flushCommitLogLeastPages=4</span>
<span class="token comment">#flushConsumeQueueLeastPages=2</span>
<span class="token comment">#flushCommitLogThoroughInterval=10000</span>
<span class="token comment">#flushConsumeQueueThoroughInterval=60000</span>
<span class="token comment">#Broker 的角色</span>
<span class="token comment">#- ASYNC_MASTER 异步复制Master</span>
<span class="token comment">#- SYNC_MASTER 同步双写Master</span>
<span class="token comment">#- SLAVE</span>
<span class="token assign-left variable">brokerRole</span><span class="token operator">=</span>SYNC_MASTER
<span class="token comment">#刷盘方式</span>
<span class="token comment">#- ASYNC_FLUSH 异步刷盘</span>
<span class="token comment">#- SYNC_FLUSH 同步刷盘</span>
<span class="token assign-left variable">flushDiskType</span><span class="token operator">=</span>SYNC_FLUSH
<span class="token comment">#checkTransactionMessageEnable=false</span>
<span class="token comment">#发消息线程池数量</span>
<span class="token comment">#sendMessageThreadPoolNums=128</span>
<span class="token comment">#拉消息线程池数量</span>
<span class="token comment">#pullMessageThreadPoolNums=128</span>
</code></pre></div><h4 id="_2-slave2"><a href="#_2-slave2" class="header-anchor">#</a> 2）<code>slave2</code></h4> <p>服务器：<code>192.168.2.12</code></p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">vim</span> /usr/local/rocketmq/conf/2m-2s-sync/new-broker-b-s.properties
</code></pre></div><p>修改配置如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">#所属集群名字</span>
<span class="token assign-left variable">brokerClusterName</span><span class="token operator">=</span>rocketmq-cluster
<span class="token comment">#broker名字，名字可重复,为了管理,每个master起一个名字,他的slave同他,eg:Bmaster叫broker-b,他的slave也叫broker-b</span>
<span class="token assign-left variable">brokerName</span><span class="token operator">=</span>broker-b
<span class="token comment">#0 表示 Master，&gt;0 表示 Slave</span>
<span class="token assign-left variable">brokerId</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token comment">#nameServer地址，分号分割</span>
<span class="token assign-left variable">namesrvAddr</span><span class="token operator">=</span>rocketmq-nameserver1:9876<span class="token punctuation">;</span>rocketmq-nameserver2:9876
<span class="token comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span>
<span class="token assign-left variable">defaultTopicQueueNums</span><span class="token operator">=</span><span class="token number">4</span>
<span class="token comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span>
<span class="token assign-left variable">autoCreateTopicEnable</span><span class="token operator">=</span>true
<span class="token comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span>
<span class="token assign-left variable">autoCreateSubscriptionGroup</span><span class="token operator">=</span>true
<span class="token comment">#Broker 对外服务的监听端口</span>
<span class="token assign-left variable">listenPort</span><span class="token operator">=</span><span class="token number">11011</span>
<span class="token comment">#删除文件时间点，默认凌晨 4点</span>
<span class="token assign-left variable">deleteWhen</span><span class="token operator">=</span>04
<span class="token comment">#文件保留时间，默认 48 小时</span>
<span class="token assign-left variable">fileReservedTime</span><span class="token operator">=</span><span class="token number">120</span>
<span class="token comment">#commitLog每个文件的大小默认1G</span>
<span class="token assign-left variable">mapedFileSizeCommitLog</span><span class="token operator">=</span><span class="token number">1073741824</span>
<span class="token comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span>
<span class="token assign-left variable">mapedFileSizeConsumeQueue</span><span class="token operator">=</span><span class="token number">300000</span>
<span class="token comment">#destroyMapedFileIntervalForcibly=120000</span>
<span class="token comment">#redeleteHangedFileInterval=120000</span>
<span class="token comment">#检测物理文件磁盘空间</span>
<span class="token assign-left variable">diskMaxUsedSpaceRatio</span><span class="token operator">=</span><span class="token number">88</span>
<span class="token comment">#存储路径</span>
<span class="token assign-left variable">storePathRootDir</span><span class="token operator">=</span>/usr/local/rocketmq/store-s
<span class="token comment">#commitLog 存储路径</span>
<span class="token assign-left variable">storePathCommitLog</span><span class="token operator">=</span>/usr/local/rocketmq/store-s/commitlog
<span class="token comment">#消费队列存储路径存储路径</span>
<span class="token assign-left variable">storePathConsumeQueue</span><span class="token operator">=</span>/usr/local/rocketmq/store-s/consumequeue
<span class="token comment">#消息索引存储路径</span>
<span class="token assign-left variable">storePathIndex</span><span class="token operator">=</span>/usr/local/rocketmq/store-s/index
<span class="token comment">#checkpoint 文件存储路径</span>
<span class="token assign-left variable">storeCheckpoint</span><span class="token operator">=</span>/usr/local/rocketmq/store-s/checkpoint
<span class="token comment">#abort 文件存储路径</span>
<span class="token assign-left variable">abortFile</span><span class="token operator">=</span>/usr/local/rocketmq/store-s/abort
<span class="token comment">#限制的消息大小</span>
<span class="token assign-left variable">maxMessageSize</span><span class="token operator">=</span><span class="token number">65536</span>
<span class="token comment">#flushCommitLogLeastPages=4</span>
<span class="token comment">#flushConsumeQueueLeastPages=2</span>
<span class="token comment">#flushCommitLogThoroughInterval=10000</span>
<span class="token comment">#flushConsumeQueueThoroughInterval=60000</span>
<span class="token comment">#Broker 的角色</span>
<span class="token comment">#- ASYNC_MASTER 异步复制Master</span>
<span class="token comment">#- SYNC_MASTER 同步双写Master</span>
<span class="token comment">#- SLAVE</span>
<span class="token assign-left variable">brokerRole</span><span class="token operator">=</span>SLAVE
<span class="token comment">#刷盘方式</span>
<span class="token comment">#- ASYNC_FLUSH 异步刷盘</span>
<span class="token comment">#- SYNC_FLUSH 同步刷盘</span>
<span class="token assign-left variable">flushDiskType</span><span class="token operator">=</span>ASYNC_FLUSH
<span class="token comment">#checkTransactionMessageEnable=false</span>
<span class="token comment">#发消息线程池数量</span>
<span class="token comment">#sendMessageThreadPoolNums=128</span>
<span class="token comment">#拉消息线程池数量</span>
<span class="token comment">#pullMessageThreadPoolNums=128</span>
</code></pre></div><h4 id="_3-master2"><a href="#_3-master2" class="header-anchor">#</a> 3）<code>master2</code></h4> <p>服务器：<code>192.168.2.13</code></p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">vim</span> /usr/local/rocketmq/conf/2m-2s-sync/new-broker-b.properties
</code></pre></div><p>修改配置如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">#所属集群名字</span>
<span class="token assign-left variable">brokerClusterName</span><span class="token operator">=</span>rocketmq-cluster
<span class="token comment">##broker名字，名字可重复,为了管理,每个master起一个名字,他的slave同他,eg:Bmaster叫broker-b,他的slave也叫broker-b</span>
<span class="token assign-left variable">brokerName</span><span class="token operator">=</span>broker-b
<span class="token comment">#0 表示 Master，&gt;0 表示 Slave</span>
<span class="token assign-left variable">brokerId</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token comment">#nameServer地址，分号分割</span>
<span class="token assign-left variable">namesrvAddr</span><span class="token operator">=</span>rocketmq-nameserver1:9876<span class="token punctuation">;</span>rocketmq-nameserver2:9876
<span class="token comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span>
<span class="token assign-left variable">defaultTopicQueueNums</span><span class="token operator">=</span><span class="token number">4</span>
<span class="token comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span>
<span class="token assign-left variable">autoCreateTopicEnable</span><span class="token operator">=</span>true
<span class="token comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span>
<span class="token assign-left variable">autoCreateSubscriptionGroup</span><span class="token operator">=</span>true
<span class="token comment">#Broker 对外服务的监听端口</span>
<span class="token assign-left variable">listenPort</span><span class="token operator">=</span><span class="token number">10911</span>
<span class="token comment">#删除文件时间点，默认凌晨 4点</span>
<span class="token assign-left variable">deleteWhen</span><span class="token operator">=</span>04
<span class="token comment">#文件保留时间，默认 48 小时</span>
<span class="token assign-left variable">fileReservedTime</span><span class="token operator">=</span><span class="token number">120</span>
<span class="token comment">#commitLog每个文件的大小默认1G</span>
<span class="token assign-left variable">mapedFileSizeCommitLog</span><span class="token operator">=</span><span class="token number">1073741824</span>
<span class="token comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span>
<span class="token assign-left variable">mapedFileSizeConsumeQueue</span><span class="token operator">=</span><span class="token number">300000</span>
<span class="token comment">#destroyMapedFileIntervalForcibly=120000</span>
<span class="token comment">#redeleteHangedFileInterval=120000</span>
<span class="token comment">#检测物理文件磁盘空间</span>
<span class="token assign-left variable">diskMaxUsedSpaceRatio</span><span class="token operator">=</span><span class="token number">88</span>
<span class="token comment">#存储路径</span>
<span class="token assign-left variable">storePathRootDir</span><span class="token operator">=</span>/usr/local/rocketmq/store
<span class="token comment">#commitLog 存储路径</span>
<span class="token assign-left variable">storePathCommitLog</span><span class="token operator">=</span>/usr/local/rocketmq/store/commitlog
<span class="token comment">#消费队列存储路径存储路径</span>
<span class="token assign-left variable">storePathConsumeQueue</span><span class="token operator">=</span>/usr/local/rocketmq/store/consumequeue
<span class="token comment">#消息索引存储路径</span>
<span class="token assign-left variable">storePathIndex</span><span class="token operator">=</span>/usr/local/rocketmq/store/index
<span class="token comment">#checkpoint 文件存储路径</span>
<span class="token assign-left variable">storeCheckpoint</span><span class="token operator">=</span>/usr/local/rocketmq/store/checkpoint
<span class="token comment">#abort 文件存储路径</span>
<span class="token assign-left variable">abortFile</span><span class="token operator">=</span>/usr/local/rocketmq/store/abort
<span class="token comment">#限制的消息大小</span>
<span class="token assign-left variable">maxMessageSize</span><span class="token operator">=</span><span class="token number">65536</span>
<span class="token comment">#flushCommitLogLeastPages=4</span>
<span class="token comment">#flushConsumeQueueLeastPages=2</span>
<span class="token comment">#flushCommitLogThoroughInterval=10000</span>
<span class="token comment">#flushConsumeQueueThoroughInterval=60000</span>
<span class="token comment">#Broker 的角色</span>
<span class="token comment">#- ASYNC_MASTER 异步复制Master</span>
<span class="token comment">#- SYNC_MASTER 同步双写Master</span>
<span class="token comment">#- SLAVE</span>
<span class="token assign-left variable">brokerRole</span><span class="token operator">=</span>SYNC_MASTER
<span class="token comment">#刷盘方式</span>
<span class="token comment">#- ASYNC_FLUSH 异步刷盘</span>
<span class="token comment">#- SYNC_FLUSH 同步刷盘</span>
<span class="token assign-left variable">flushDiskType</span><span class="token operator">=</span>SYNC_FLUSH
<span class="token comment">#checkTransactionMessageEnable=false</span>
<span class="token comment">#发消息线程池数量</span>
<span class="token comment">#sendMessageThreadPoolNums=128</span>
<span class="token comment">#拉消息线程池数量</span>
<span class="token comment">#pullMessageThreadPoolNums=128</span>
</code></pre></div><h4 id="_4-slave1"><a href="#_4-slave1" class="header-anchor">#</a> 4）<code>slave1</code></h4> <p>服务器：<code>192.168.2.13</code></p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">vim</span> /usr/local/rocketmq/conf/2m-2s-sync/new-broker-a-s.properties
</code></pre></div><p>修改配置如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">#所属集群名字</span>
<span class="token assign-left variable">brokerClusterName</span><span class="token operator">=</span>rocketmq-cluster
<span class="token comment">##broker名字，名字可重复,为了管理,每个master起一个名字,他的slave同他,eg:Amaster叫broker-a,他的slave也叫broker-a</span>
<span class="token assign-left variable">brokerName</span><span class="token operator">=</span>broker-a
<span class="token comment">#0 表示 Master，&gt;0 表示 Slave</span>
<span class="token assign-left variable">brokerId</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token comment">#nameServer地址，分号分割</span>
<span class="token assign-left variable">namesrvAddr</span><span class="token operator">=</span>rocketmq-nameserver1:9876<span class="token punctuation">;</span>rocketmq-nameserver2:9876
<span class="token comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span>
<span class="token assign-left variable">defaultTopicQueueNums</span><span class="token operator">=</span><span class="token number">4</span>
<span class="token comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span>
<span class="token assign-left variable">autoCreateTopicEnable</span><span class="token operator">=</span>true
<span class="token comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span>
<span class="token assign-left variable">autoCreateSubscriptionGroup</span><span class="token operator">=</span>true
<span class="token comment">#Broker 对外服务的监听端口</span>
<span class="token assign-left variable">listenPort</span><span class="token operator">=</span><span class="token number">11011</span>
<span class="token comment">#删除文件时间点，默认凌晨 4点</span>
<span class="token assign-left variable">deleteWhen</span><span class="token operator">=</span>04
<span class="token comment">#文件保留时间，默认 48 小时</span>
<span class="token assign-left variable">fileReservedTime</span><span class="token operator">=</span><span class="token number">120</span>
<span class="token comment">#commitLog每个文件的大小默认1G</span>
<span class="token assign-left variable">mapedFileSizeCommitLog</span><span class="token operator">=</span><span class="token number">1073741824</span>
<span class="token comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span>
<span class="token assign-left variable">mapedFileSizeConsumeQueue</span><span class="token operator">=</span><span class="token number">300000</span>
<span class="token comment">#destroyMapedFileIntervalForcibly=120000</span>
<span class="token comment">#redeleteHangedFileInterval=120000</span>
<span class="token comment">#检测物理文件磁盘空间</span>
<span class="token assign-left variable">diskMaxUsedSpaceRatio</span><span class="token operator">=</span><span class="token number">88</span>
<span class="token comment">#存储路径</span>
<span class="token assign-left variable">storePathRootDir</span><span class="token operator">=</span>/usr/local/rocketmq/store-s
<span class="token comment">#commitLog 存储路径</span>
<span class="token assign-left variable">storePathCommitLog</span><span class="token operator">=</span>/usr/local/rocketmq/store-s/commitlog
<span class="token comment">#消费队列存储路径存储路径</span>
<span class="token assign-left variable">storePathConsumeQueue</span><span class="token operator">=</span>/usr/local/rocketmq/store-s/consumequeue
<span class="token comment">#消息索引存储路径</span>
<span class="token assign-left variable">storePathIndex</span><span class="token operator">=</span>/usr/local/rocketmq/store-s/index
<span class="token comment">#checkpoint 文件存储路径</span>
<span class="token assign-left variable">storeCheckpoint</span><span class="token operator">=</span>/usr/local/rocketmq/store-s/checkpoint
<span class="token comment">#abort 文件存储路径</span>
<span class="token assign-left variable">abortFile</span><span class="token operator">=</span>/usr/local/rocketmq/store-s/abort
<span class="token comment">#限制的消息大小</span>
<span class="token assign-left variable">maxMessageSize</span><span class="token operator">=</span><span class="token number">65536</span>
<span class="token comment">#flushCommitLogLeastPages=4</span>
<span class="token comment">#flushConsumeQueueLeastPages=2</span>
<span class="token comment">#flushCommitLogThoroughInterval=10000</span>
<span class="token comment">#flushConsumeQueueThoroughInterval=60000</span>
<span class="token comment">#Broker 的角色</span>
<span class="token comment">#- ASYNC_MASTER 异步复制Master</span>
<span class="token comment">#- SYNC_MASTER 同步双写Master</span>
<span class="token comment">#- SLAVE</span>
<span class="token assign-left variable">brokerRole</span><span class="token operator">=</span>SLAVE
<span class="token comment">#刷盘方式</span>
<span class="token comment">#- ASYNC_FLUSH 异步刷盘</span>
<span class="token comment">#- SYNC_FLUSH 同步刷盘</span>
<span class="token assign-left variable">flushDiskType</span><span class="token operator">=</span>ASYNC_FLUSH
<span class="token comment">#checkTransactionMessageEnable=false</span>
<span class="token comment">#发消息线程池数量</span>
<span class="token comment">#sendMessageThreadPoolNums=128</span>
<span class="token comment">#拉消息线程池数量</span>
<span class="token comment">#pullMessageThreadPoolNums=128</span>
</code></pre></div><h3 id="修改启动脚本文件"><a href="#修改启动脚本文件" class="header-anchor">#</a> 修改启动脚本文件</h3> <h4 id="_1-runbroker-sh"><a href="#_1-runbroker-sh" class="header-anchor">#</a> 1）<code>runbroker.sh</code></h4> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">vi</span> /usr/local/rocketmq/bin/runbroker.sh
</code></pre></div><p>需要根据内存大小进行适当的对JVM参数进行调整：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment">#===================================================</span>
<span class="token comment"># 开发环境配置 JVM Configuration</span>
<span class="token assign-left variable">JAVA_OPT</span><span class="token operator">=</span><span class="token string">&quot;<span class="token variable">${JAVA_OPT}</span> -server -Xms256m -Xmx256m -Xmn128m&quot;</span>
</code></pre></div><h4 id="_2-runserver-sh"><a href="#_2-runserver-sh" class="header-anchor">#</a> 2）<code>runserver.sh</code></h4> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">vim</span> /usr/local/rocketmq/bin/runserver.sh
<span class="token assign-left variable">JAVA_OPT</span><span class="token operator">=</span><span class="token string">&quot;<span class="token variable">${JAVA_OPT}</span> -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span>
</code></pre></div><h3 id="服务启动"><a href="#服务启动" class="header-anchor">#</a> 服务启动</h3> <h4 id="_1-启动nameserver集群"><a href="#_1-启动nameserver集群" class="header-anchor">#</a> 1）启动<code>NameServer</code>集群</h4> <p>分别在<code>192.168.2.12</code>和<code>192.168.2.13</code>启动<code>NameServer</code></p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> /usr/local/rocketmq/bin
<span class="token function">nohup</span> <span class="token function">sh</span> mqnamesrv <span class="token operator">&amp;</span>
</code></pre></div><h4 id="_2-启动broker集群"><a href="#_2-启动broker集群" class="header-anchor">#</a> 2）启动<code>Broker</code>集群</h4> <ul><li>在<code>192.168.2.12</code>上启动<code>master1</code>和<code>slave2</code></li></ul> <p><code>master1</code>：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">cd</span> /usr/local/rocketmq/bin
<span class="token function">nohup</span> <span class="token function">sh</span> mqbroker -c /usr/local/rocketmq/conf/2m-2s-sync/new-broker-a.properties <span class="token operator">&amp;</span>
</code></pre></div><p><code>slave2</code>：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">cd</span> /usr/local/rocketmq/bin
<span class="token function">nohup</span> <span class="token function">sh</span> mqbroker -c /usr/local/rocketmq/conf/2m-2s-sync/new-broker-b-s.properties <span class="token operator">&amp;</span>
</code></pre></div><ul><li>在<code>192.168.2.13</code>上启动<code>master2</code>和<code>slave2</code></li></ul> <p><code>master2</code></p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">cd</span> /usr/local/rocketmq/bin
<span class="token function">nohup</span> <span class="token function">sh</span> mqbroker -c /usr/local/rocketmq/conf/2m-2s-sync/new-broker-b.properties <span class="token operator">&amp;</span>
</code></pre></div><p><code>slave1</code></p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">cd</span> /usr/local/rocketmq/bin
<span class="token function">nohup</span> <span class="token function">sh</span> mqbroker -c /usr/local/rocketmq/conf/2m-2s-sync/new-broker-a-s.properties <span class="token operator">&amp;</span>
</code></pre></div><h3 id="查看进程状态"><a href="#查看进程状态" class="header-anchor">#</a> 查看进程状态</h3> <p>启动后通过<code>JPS</code>查看启动进程</p> <h3 id="查看日志"><a href="#查看日志" class="header-anchor">#</a> 查看日志</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 查看nameServer日志</span>
<span class="token function">tail</span> -500f ~/logs/rocketmqlogs/namesrv.log
<span class="token comment"># 查看broker日志</span>
<span class="token function">tail</span> -500f ~/logs/rocketmqlogs/broker.log
</code></pre></div><h2 id="rocketmq集群监控平台搭建"><a href="#rocketmq集群监控平台搭建" class="header-anchor">#</a> RocketMQ集群监控平台搭建</h2> <h3 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h3> <p><code>RocketMQ</code>有一个对其扩展的开源项目<a href="https://github.com/apache/rocketmq-externals" target="_blank" rel="noopener noreferrer">incubator-rocketmq-externals<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，这个项目中有一个子模块叫<code>rocketmq-console</code>，这个便是管理控制台项目了，先将<a href="https://github.com/apache/rocketmq-externals" target="_blank" rel="noopener noreferrer">incubator-rocketmq-externals<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>拉到本地，因为我们需要自己对<code>rocketmq-console</code>进行编译打包运行。</p> <h3 id="下载并编译打包"><a href="#下载并编译打包" class="header-anchor">#</a> 下载并编译打包</h3> <p>方式一：git clone</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">git</span> clone https://github.com/apache/rocketmq-externals
<span class="token builtin class-name">cd</span> rocketmq-console
mvn clean package -Dmaven.test.skip<span class="token operator">=</span>true
</code></pre></div><p>方式二：虚拟机没安装Git，下载zip包</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">wget</span> -O rocketmq-externals-master.zip https://github.com/apache/rocketmq-externals/archive/master.zip
</code></pre></div><p>进入rocketmq-console的src/main/resources/文件夹</p> <blockquote><p>注意：打包前在<code>rocketmq-console</code>中配置<code>namesrv</code>集群地址：src/ application.properties</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code># 这里注意修改
rocketmq.config.namesrvAddr=192.168.2.12:9876;192.168.2.13:9876
</code></pre></div><p>maven环境配置</p> <blockquote><ol><li><p>下载maven安装文件</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">wget</span> http://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz
</code></pre></div></li> <li><p>解压安装</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">tar</span> -zxvf apache-maven-3.3.9-bin.tar.gz
<span class="token function">mv</span> apache-maven-3.3.9 /usr/local/maven 
</code></pre></div></li> <li><p>配置环境变量</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">vim</span> /etc/profile
</code></pre></div><div class="language-shell extra-class"><pre class="language-shell"><code><span class="token assign-left variable">M2_HOME</span><span class="token operator">=</span>/usr/local/maven 
<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token variable">${M2_HOME}</span>/bin:<span class="token variable">${<span class="token environment constant">PATH</span>}</span>
</code></pre></div></li> <li><p>重载/etc/profile这个文件</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">source</span> /etc/profile
</code></pre></div></li></ol></blockquote> <p>使用maven打包命令打包或者在本地编译，把编译后jar包上传到对应服务器</p> <div class="language-java extra-class"><pre class="language-java"><code>mvn clean <span class="token keyword">package</span> <span class="token operator">-</span><span class="token class-name">Dmaven</span><span class="token punctuation">.</span>test<span class="token punctuation">.</span>skip<span class="token operator">=</span><span class="token boolean">true</span>
</code></pre></div><p>启动<code>rocketmq-console</code>：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>java -jar rocketmq-console-ng-1.0.0.jar
</code></pre></div><p>启动成功后，我们就可以通过浏览器访问<code>http://x.x.x.x:8080</code>进入控制台界面了，如下图：</p> <p><img src="/study/assets/img/1580998-20200609193702477-1571247230.b43a3b6a.png" alt="img"></p> <h2 id="消息发送样例"><a href="#消息发送样例" class="header-anchor">#</a> 消息发送样例</h2> <h3 id="基本样例"><a href="#基本样例" class="header-anchor">#</a> 基本样例</h3> <ul><li><p>导入MQ客户端依赖</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.rocketmq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>rocketmq-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>消息发送者步骤分析</p></li> <li><ol><li>创建消息生产者producer，并指定生产者组名</li> <li>指定NameServer地址</li> <li>启动producer</li> <li>创建消息对象，指定主题Topic、Tag和消息体</li> <li>发送消息</li> <li>关闭生产者producer</li></ol></li> <li><p>消息消费者步骤分析</p> <ol><li>创建消费者consumer，指定消费者组名</li> <li>指定NameServer地址</li> <li>订阅主题Topic和Tag</li> <li>设置回调函数，处理消息</li> <li>启动消费者consumer</li></ol></li></ul> <h4 id="消息发送"><a href="#消息发送" class="header-anchor">#</a> 消息发送</h4> <h5 id="同步发送"><a href="#同步发送" class="header-anchor">#</a> 同步发送</h5> <p><img src="/study/assets/img/20190612160605277.b3b83bbb.png" alt="img"></p> <p>简单来说，同步发送就是指 producer 发送消息后，会在接收到 broker 响应后才继续发下一条消息的通信方式。</p> <p>由于这种同步发送的方式确保了消息的可靠性，同时也能及时得到消息发送的结果，故而适合一些发送比较重要的消息场景，比如：<strong>重要通知邮件、报名短信通知、营销短信</strong>等等。在实际应用中，这种同步发送的方式还是用得比较多的。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>producer<span class="token punctuation">.</span></span><span class="token class-name">DefaultMQProducer</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>producer<span class="token punctuation">.</span></span><span class="token class-name">SendResult</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>common<span class="token punctuation">.</span>message<span class="token punctuation">.</span></span><span class="token class-name">Message</span><span class="token punctuation">;</span>
 
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span><span class="token punctuation">;</span>
 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SyncProducer</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1.创建消息生产者producer，并制定生产者组名</span>
        <span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">&quot;group1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2.指定NameServer地址,多个地址用 ; 隔开</span>
        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">&quot;localhost:9876&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3.启动producer</span>
        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 4.创建消息对象，指定主题Topic、Tag和消息体</span>
            <span class="token comment">/*
            参数1：消息主题Topic
            参数2：消息Tag
            参数3：消息内容
             */</span>
            <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">&quot;base&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;tag1&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 5.发送消息结果包含  发送状态  消息id 消息接收队列id等</span>
            <span class="token class-name">SendResult</span> result <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;发送结果&quot;</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
            <span class="token comment">// 线程睡眠1秒</span>
            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 6关闭生产者producer</span>
        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="异步发送"><a href="#异步发送" class="header-anchor">#</a> 异步发送</h5> <p><img src="/study/assets/img/20190612160633284.ccbe64bc.png" alt="img"></p> <p>异步发送是指 producer 发出一条消息后，不需要等待 broker 响应，就接着发送下一条消息的通信方式。需要注意的是，不等待 broker 响应，并不意味着 broker 不响应，而是通过回调接口来接收 broker 的响应。所以要记住一点，异步发送同样可以对消息的响应结果进行处理。</p> <p>由于异步发送不需要等待 broker 的响应，故在一些比较注重 RT（响应时间）的场景就会比较适用。比如，在一些视频上传的场景，我们知道视频上传之后需要进行转码，如果使用同步发送的方式来通知启动转码服务，那么就需要等待转码完成才能发回转码结果的响应，由于转码时间往往较长，很容易造成响应超时。此时，如果使用的是异步发送通知转码服务，那么就可以等转码完成后，再通过回调接口来接收转码结果的响应了。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>producer<span class="token punctuation">.</span></span><span class="token class-name">DefaultMQProducer</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>producer<span class="token punctuation">.</span></span><span class="token class-name">SendCallback</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>producer<span class="token punctuation">.</span></span><span class="token class-name">SendResult</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>common<span class="token punctuation">.</span>message<span class="token punctuation">.</span></span><span class="token class-name">Message</span><span class="token punctuation">;</span>
 
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span><span class="token punctuation">;</span>
 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AsyncProducer</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1.创建消息生产者producer，并制定生产者组名</span>
        <span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">&quot;group1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2.指定NameServer地址</span>
        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">&quot;localhost:9876&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3.启动producer</span>
        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 4.创建消息对象，指定主题Topic、Tag和消息体</span>
            <span class="token comment">/*
            参数1：消息主题Topic
            参数2：消息Tag
            参数3：消息内容
             */</span>
            <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">&quot;base&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;tag2&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 5.发送消息结果包含  发送状态  消息id 消息接收队列id等</span>
            producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SendCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 发送成功回调函数</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span><span class="token class-name">SendResult</span> sendResult<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;发送结果：&quot;</span><span class="token operator">+</span>sendResult<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 发送失败回调函数</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onException</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;发送异常&quot;</span><span class="token operator">+</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
            <span class="token comment">// 线程睡眠1秒</span>
            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 6关闭生产者producer</span>
        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;发送完成&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="单向发送"><a href="#单向发送" class="header-anchor">#</a> 单向发送</h5> <p><img src="/study/assets/img/20190612160654330.623182e4.png" alt="img"></p> <p>单向发送，见名知意，就是一种单方向通信方式，也就是说 producer 只负责发送消息，不等待 broker 发回响应结果，而且也没有回调函数触发，这也就意味着 producer 只发送请求不等待响应结果。</p> <p>由于单向发送只是简单地发送消息，不需要等待响应，也没有回调接口触发，故发送消息所耗费的时间非常短，同时也意味着消息不可靠。所以这种单向发送比较适用于那些耗时要求非常短，但对可靠性要求并不高的场景，比如：<strong>日志收集</strong>。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">MQBrokerException</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">MQClientException</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>producer<span class="token punctuation">.</span></span><span class="token class-name">DefaultMQProducer</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>common<span class="token punctuation">.</span>message<span class="token punctuation">.</span></span><span class="token class-name">Message</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>remoting<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">RemotingException</span><span class="token punctuation">;</span>
 
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span><span class="token punctuation">;</span>
 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OnewayProducer</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1.创建消息生产者producer，并制定生产者组名</span>
        <span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">&quot;group1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2.指定NameServer地址</span>
        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">&quot;localhost:9876&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3.启动producer</span>
        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 4.创建消息对象，指定主题Topic、Tag和消息体</span>
            <span class="token comment">/*
            参数1：消息主题Topic
            参数2：消息Tag
            参数3：消息内容
             */</span>
            <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">&quot;base&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;tag3&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">&quot;hello world,单向消息&quot;</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 5.发送单向消息</span>
            producer<span class="token punctuation">.</span><span class="token function">sendOneway</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;发送单向消息&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
            <span class="token comment">// 线程睡眠1秒</span>
            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 6关闭生产者producer</span>
        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h5> <p>下表概括了三者的特点和主要区别。</p> <table><thead><tr><th style="text-align:left;">发送方式</th> <th style="text-align:left;">发送 TPS</th> <th style="text-align:left;">发送结果反馈</th> <th style="text-align:left;">可靠性</th></tr></thead> <tbody><tr><td style="text-align:left;">同步发送</td> <td style="text-align:left;">快</td> <td style="text-align:left;">有</td> <td style="text-align:left;">不丢失</td></tr> <tr><td style="text-align:left;">异步发送</td> <td style="text-align:left;">快</td> <td style="text-align:left;">有</td> <td style="text-align:left;">不丢失</td></tr> <tr><td style="text-align:left;">单向发送</td> <td style="text-align:left;">最快</td> <td style="text-align:left;">无</td> <td style="text-align:left;">可能丢失</td></tr></tbody></table> <blockquote><p>可以看到，从发送 TPS 来看，由于单向发送不需要等待响应也没有回调接口触发，发送速度非常快，一般都是微秒级的，在消息体大小一样的情况下，其发送 TPS 最大。而同步发送，需要等待响应结果的返回，受网络状况的影响较大，故发送 TPS 就比较小。异步发送不等待响应结果，发送消息时几乎不受网络的影响，故相比同步发送来说，其发送 TPS 要大得多。</p> <p>关于可靠性，大家需要牢记前面提过的，异步发送并不意味着消息不可靠，异步发送也是会接收到响应结果，也能对响应结果进行处理。即使发送失败，也可以通过一些补偿手段进行消息重发。和同步发送比起来，异步发送的发送 TPS 更大，更适合那些调用链路较长的一些场景。在实际使用中，同步发送和异步发送都是较为常用的两种方式，大家要视具体业务场景进行合理地选择。</p></blockquote> <h4 id="消息消费"><a href="#消息消费" class="header-anchor">#</a> 消息消费</h4> <h5 id="集群消费-负载均衡模式"><a href="#集群消费-负载均衡模式" class="header-anchor">#</a> 集群消费（负载均衡模式）</h5> <p>首先明确一点，RocketMQ 是基于发布订阅模型的消息中间件。所谓的发布订阅就是说，consumer 订阅了 broker 上的某个 topic，当 producer 发布消息到 broker 上的该 topic 时，consumer 就能收到该条消息。</p> <p>之前我们讲过 consumer group 的概念，即消费同一类消息的多个 consumer 实例组成一个消费者组，也可以称为一个 consumer 集群，这些 consumer 实例使用同一个 group name。</p> <p>需要注意一点，除了使用同一个 group name，订阅的 tag 也必须是一样的，只有符合这两个条件的 consumer 实例才能组成 consumer 集群。</p> <p><img src="/study/assets/img/20190612161104489.fdb1a340.png" alt="img"></p> <p>当 consumer 使用集群消费时，每条消息只会被 consumer 集群内的任意一个 consumer 实例消费一次。举个例子，当一个 consumer 集群内有 3 个consumer 实例（假设为consumer 1、consumer 2、consumer 3）时，一条消息投递过来，只会被consumer 1、consumer 2、consumer 3中的一个消费。</p> <p>同时记住一点，使用集群消费的时候，consumer 的消费进度是存储在 broker 上，consumer 自身是不存储消费进度的。消息进度存储在 broker 上的好处在于，当你 consumer 集群是扩大或者缩小时，由于消费进度统一在broker上，消息重复的概率会被大大降低了。</p> <p>注意：在集群消费模式下，并不能保证每一次消息失败重投都投递到同一个 consumer 实例。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span></span><span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>listener<span class="token punctuation">.</span></span><span class="token class-name">ConsumeConcurrentlyContext</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>listener<span class="token punctuation">.</span></span><span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>listener<span class="token punctuation">.</span></span><span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">MQClientException</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>common<span class="token punctuation">.</span>message<span class="token punctuation">.</span></span><span class="token class-name">MessageExt</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>common<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span>heartbeat<span class="token punctuation">.</span></span><span class="token class-name">MessageModel</span><span class="token punctuation">;</span>
 
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span>
 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1.创建消费者Consumer，制定消费者组名</span>
        <span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">&quot;group1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2.指定Nameserver地址</span>
        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">&quot;localhost:9876&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3.订阅主题Topic和Tag</span>
        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;base&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;tag1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 消费模式：默认是负载均衡模式</span>
        consumer<span class="token punctuation">.</span><span class="token function">setMessageModel</span><span class="token punctuation">(</span><span class="token class-name">MessageModel</span><span class="token punctuation">.</span>CLUSTERING<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4.设置回调函数，处理消息</span>
        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//接收消息内容</span>
            <span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token class-name">ConsumeConcurrentlyContext</span> consumeConcurrentlyContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">MessageExt</span> messageExt <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>messageExt<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 5.启动消费者consumer</span>
        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>分别启动多个 consumer 实例，会发现如果只有一条消息，只会被某一个 consumer 消费</p> <h5 id="广播消费"><a href="#广播消费" class="header-anchor">#</a> 广播消费</h5> <p><img src="/study/assets/img/20190612161120673.573826a3.png" alt="img"></p> <p>当 consumer 使用广播消费时，每条消息都会被 consumer 集群内所有的 consumer 实例消费一次，也就是说每条消息至少被每一个 consumer 实例消费一次。举个例子，当一个 consumer 集群内有 3 个 consumer 实例（假设为 consumer 1、consumer 2、consumer 3）时，一条消息投递过来，会被 consumer 1、consumer 2、consumer 3都消费一次。</p> <p>与集群消费不同的是，consumer 的<strong>消费进度</strong>是存储在<strong>各个 consumer 实例</strong>上，这就容易造成消息重复。还有很重要的一点，对于广播消费来说，是<strong>不会</strong>进行消费失败<strong>重投</strong>的，所以在 consumer 端消费逻辑处理时，需要额外关注消费失败的情况。</p> <p>虽然广播消费能保证集群内每个 consumer 实例都能消费消息，但是消费进度的维护、不具备消息重投的机制大大影响了实际的使用。因此，在实际使用中，更推荐使用集群消费，因为集群消费不仅拥有消费进度存储的可靠性，还具有消息重投的机制。而且，我们通过集群消费也可以达到广播消费的效果。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span></span><span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>listener<span class="token punctuation">.</span></span><span class="token class-name">ConsumeConcurrentlyContext</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>listener<span class="token punctuation">.</span></span><span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>listener<span class="token punctuation">.</span></span><span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>exception<span class="token punctuation">.</span></span><span class="token class-name">MQClientException</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>common<span class="token punctuation">.</span>message<span class="token punctuation">.</span></span><span class="token class-name">MessageExt</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token punctuation">.</span>common<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span>heartbeat<span class="token punctuation">.</span></span><span class="token class-name">MessageModel</span><span class="token punctuation">;</span>
 
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span>
 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MQClientException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1.创建消费者Consumer，制定消费者组名</span>
        <span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">&quot;group1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2.指定Nameserver地址</span>
        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">&quot;localhost:9876&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3.订阅主题Topic和Tag</span>
        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;base&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;tag1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 消费模式：广播模式</span>
        consumer<span class="token punctuation">.</span><span class="token function">setMessageModel</span><span class="token punctuation">(</span><span class="token class-name">MessageModel</span><span class="token punctuation">.</span>BROADCASTING<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4.设置回调函数，处理消息（并发）</span>
        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//接收消息内容</span>
            <span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token class-name">ConsumeConcurrentlyContext</span> consumeConcurrentlyContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">MessageExt</span> messageExt <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>messageExt<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 5.启动消费者consumer</span>
        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="集群消费模拟广播消费"><a href="#集群消费模拟广播消费" class="header-anchor">#</a> 集群消费模拟广播消费</h5> <p><img src="/study/assets/img/2019061216113698.28a0fca4.png" alt="img"></p> <p>如果业务上确实需要使用广播消费，那么我们可以通过创建多个 consumer 实例，每个 consumer 实例属于不同的 consumer group，但是它们都订阅同一个 topic。</p> <p>举个例子，我们创建 3 个 consumer 实例，consumer 1（属于consumer group 1）、consumer 2（属于 consumer group 2）、consumer 3（属于consumer group 3），它们都订阅了 topic A ，那么当 producer 发送一条消息到 topic A 上时，由于 3 个consumer 属于不同的 consumer group，所以 3 个consumer都能收到消息，也就达到了广播消费的效果了。 除此之外，每个 consumer 实例的消费逻辑可以一样也可以不一样，每个consumer group还可以根据需要增加 consumer 实例，比起广播消费来说更加灵活。</p> <h3 id="普通消息"><a href="#普通消息" class="header-anchor">#</a> 普通消息</h3> <p>普通消息也叫做无序消息，简单来说就是没有顺序的消息，producer 只管发送消息，consumer 只管接收消息，至于消息和消息之间的顺序并没有保证，可能先发送的消息先消费，也可能先发送的消息后消费。</p> <p>举个简单例子，producer 依次发送 order id 为 1、2、3 的消息到 broker，consumer 接到的消息顺序有可能是 1、2、3，也有可能是 2、1、3 等情况，这就是普通消息。</p> <p>因为不需要保证消息的顺序，所以消息可以大规模并发地发送和消费，吞吐量很高，适合大部分场景。</p> <p>代码实例：</p> <ul><li><p>生产者</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MQClientException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
 
        <span class="token comment">//声明并初始化一个producer</span>
        <span class="token comment">//需要一个producer group名字作为构造方法的参数，这里为concurrent_producer</span>
        <span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">&quot;concurrent_producer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//设置NameServer地址,此处应改为实际NameServer地址，多个地址之间用；分隔</span>
        <span class="token comment">//NameServer的地址必须有，但是也可以通过环境变量的方式设置，不一定非得写死在代码里</span>
        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">&quot;10.1.54.121:9876;10.1.54.122:9876&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//调用start()方法启动一个producer实例</span>
        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//发送10条消息到Topic为TopicTest，tag为TagA，消息内容为“Hello RocketMQ”拼接上i的值</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">&quot;TopicTestConcurrent&quot;</span><span class="token punctuation">,</span><span class="token comment">// topic</span>
                        <span class="token string">&quot;TagA&quot;</span><span class="token punctuation">,</span><span class="token comment">// tag</span>
                        <span class="token punctuation">(</span><span class="token string">&quot;Hello RocketMQ &quot;</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">RemotingHelper</span><span class="token punctuation">.</span>DEFAULT_CHARSET<span class="token punctuation">)</span><span class="token comment">// body</span>
                <span class="token punctuation">)</span><span class="token punctuation">;</span>
 
                <span class="token comment">//调用producer的send()方法发送消息</span>
                <span class="token comment">//这里调用的是同步的方式，所以会有返回结果，同时默认发送的也是普通消息</span>
                <span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
                <span class="token comment">//打印返回结果，可以看到消息发送的状态以及一些相关信息</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sendResult<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
 
        <span class="token comment">//发送完消息之后，调用shutdown()方法关闭producer</span>
        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>消费者</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">MQClientException</span> <span class="token punctuation">{</span>
 
        <span class="token comment">//声明并初始化一个consumer</span>
        <span class="token comment">//需要一个consumer group名字作为构造方法的参数，这里为concurrent_consumer</span>
        <span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">&quot;concurrent_consumer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//同样也要设置NameServer地址</span>
        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">&quot;10.1.54.121:9876;10.1.54.122:9876&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//这里设置的是一个consumer的消费策略</span>
        <span class="token comment">//CONSUME_FROM_LAST_OFFSET 默认策略，从该队列最尾开始消费，即跳过历史消息</span>
        <span class="token comment">//CONSUME_FROM_FIRST_OFFSET 从队列最开始开始消费，即历史消息（还储存在broker的）全部消费一遍</span>
        <span class="token comment">//CONSUME_FROM_TIMESTAMP 从某个时间点开始消费，和setConsumeTimestamp()配合使用，默认是半个小时以前</span>
        consumer<span class="token punctuation">.</span><span class="token function">setConsumeFromWhere</span><span class="token punctuation">(</span><span class="token class-name">ConsumeFromWhere</span><span class="token punctuation">.</span>CONSUME_FROM_FIRST_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//设置consumer所订阅的Topic和Tag，*代表全部的Tag</span>
        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;TopicTestConcurrent&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//设置一个Listener，主要进行消息的逻辑处理</span>
        <span class="token comment">//注意这里使用的是MessageListenerConcurrently这个接口</span>
        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">&gt;</span></span> msgs<span class="token punctuation">,</span>
                                                            <span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; Receive New Messages: &quot;</span> <span class="token operator">+</span> msgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
                <span class="token comment">//返回消费状态</span>
                <span class="token comment">//CONSUME_SUCCESS 消费成功</span>
                <span class="token comment">//RECONSUME_LATER 消费失败，需要稍后重新消费</span>
                <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//调用start()方法启动consumer</span>
        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Consumer Started.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="有序消息"><a href="#有序消息" class="header-anchor">#</a> 有序消息</h3> <p>有序消息就是按照一定的先后顺序的消息类型。</p> <p>举个例子来说，producer 依次发送 order id 为 1、2、3 的消息到 broker，consumer 接到的消息顺序也就是 1、2、3 ，而不会出现普通消息那样的 2、1、3 等情况。</p> <p>那么有序消息是如何保证的呢？我们都知道消息首先由 producer 到 broker，再从 broker 到 consumer，分这两步走。那么要保证消息的有序，势必这两步都是要保证有序的，即要保证消息是按有<strong>序发送到 broker</strong>，broker 也是<strong>有序将消息投递给 consumer</strong>，两个条件必须同时满足，缺一不可。
进一步还可以将有序消息分成</p> <ul><li>全局有序消息</li> <li>局部有序消息</li></ul> <p>之前我们讲过，topic 只是消息的逻辑分类，内部实现其实是由 queue 队列 组成。当 producer 把消息发送到某个 topic 时，默认是会消息发送到具体的 queue 队列 上。</p> <h4 id="_1-全局有序"><a href="#_1-全局有序" class="header-anchor">#</a> 1）全局有序</h4> <p><img src="/study/assets/img/20190612160227808.eadff9a6.png" alt="img"></p> <p>举个例子，producer 发送 order id 为 1、2、3、4 的四条消息到 topicA 上，假设 topicA 的 queue 数为 3 个（queue0、queue1、queue2），那么消息的分布可能就是这种情况，id 为 1 的在 queue0，id 为 2 的在 queue1，id 为 3 的在 queue2，id 为 4 的在 queue0。同样的，consumer 消费时也是按 queue 去消费，这时候就可能出现先消费 1、4，再消费 2、3，和我们的预期不符。</p> <p>那么我们如何实现 1、2、3、4 的消费顺序呢？道理其实很简单，只需要把订单 topic 的 queue 数改为 1，如此一来，只要 producer 按照 1、2、3、4 的顺序去发送消息，那么 consumer 自然也就按照 1、2、3、4 的顺序去消费，这就是全局有序消息。</p> <p>由于一个 topic 只有一个 queue ，即使我们有多个 producer 实例和 consumer 实例也很难提高消息吞吐量。就好比过独木桥，大家只能一个挨着一个过去，效率低下。</p> <p>那么有没有吞吐量和有序之间折中的方案呢？其实是有的，就是局部有序消息。</p> <h4 id="_2-局部有序"><a href="#_2-局部有序" class="header-anchor">#</a> 2）局部有序</h4> <p><img src="/study/assets/img/20190612160235276.e54cf92b.png" alt="img"></p> <p>我们知道订单消息可以再细分为订单创建、订单付款、订单完成等消息，这些消息都有相同的 order id。同时，也只有按照订单创建、订单付款、订单完成的顺序去消费才符合业务逻辑。但是不同 order id 的消息是可以并行的，不会影响到业务。这时候就常见做法就是将 order id 进行处理，将 order id 相同的消息发送到 topicB 的同一个 queue，假设我们 topicB 有 2 个 queue，那么我们可以简单的对 order id对队列集合大小求余来返回所对应的队列，消费者按照 queue 去消费时，就能保证 queue0 里面的消息有序消费，queue1 里面的消息有序消费。</p> <p>由于一个 topic 可以有多个 queue，所以在性能比全局有序高得多。假设 queue 数是 n，理论上性能就是全局有序的 n 倍，当然 consumer 也要跟着增加才行。在实际情况中，这种局部有序消息是会比全局有序消息用的更多。</p> <p>示例代码：</p> <ul><li><p>生产者</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">UnsupportedEncodingException</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 声明并初始化一个producer</span>
            <span class="token comment">// 需要一个producer group名字作为构造方法的参数，这里为ordered_producer</span>
            <span class="token class-name">DefaultMQProducer</span> orderedProducer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">&quot;ordered_producer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
            <span class="token comment">// 设置NameServer地址,此处应改为实际NameServer地址，多个地址之间用；分隔</span>
            <span class="token comment">//NameServer的地址必须有，但是也可以通过环境变量的方式设置，不一定非得写死在代码里</span>
            orderedProducer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">&quot;10.1.54.121:9876;10.1.54.122:9876&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
            <span class="token comment">// 调用start()方法启动一个producer实例</span>
            orderedProducer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
            <span class="token comment">// 自定义一个tag数组</span>
            <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tags <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">&quot;TagA&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;TagB&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;TagC&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;TagD&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;TagE&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
 
            <span class="token comment">// 发送10条消息到Topic为TopicTestOrdered，tag为tags数组按顺序取值，</span>
            <span class="token comment">// key值为“KEY”拼接上i的值，消息内容为“Hello RocketMQ”拼接上i的值</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
                <span class="token keyword">int</span> orderId <span class="token operator">=</span> i <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>
                <span class="token class-name">Message</span> msg <span class="token operator">=</span>
                        <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">&quot;TopicTestOrdered&quot;</span><span class="token punctuation">,</span> tags<span class="token punctuation">[</span>i <span class="token operator">%</span> tags<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">&quot;KEY&quot;</span> <span class="token operator">+</span> i<span class="token punctuation">,</span>
                                <span class="token punctuation">(</span><span class="token string">&quot;Hello RocketMQ &quot;</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
                <span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> orderedProducer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueueSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
                    <span class="token comment">// 选择发送消息的队列</span>
                    <span class="token annotation punctuation">@Override</span>
                    <span class="token keyword">public</span> <span class="token class-name">MessageQueue</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageQueue</span><span class="token punctuation">&gt;</span></span> mqs<span class="token punctuation">,</span> <span class="token class-name">Message</span> msg<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
                        <span class="token comment">// arg的值其实就是orderId</span>
                        <span class="token class-name">Integer</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span> arg<span class="token punctuation">;</span>
 
                        <span class="token comment">// mqs是队列集合，也就是topic所对应的所有队列</span>
                        <span class="token keyword">int</span> index <span class="token operator">=</span> id <span class="token operator">%</span> mqs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
                        <span class="token comment">// 这里根据前面的id对队列集合大小求余来返回所对应的队列</span>
                        <span class="token keyword">return</span> mqs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span> orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sendResult<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
 
            orderedProducer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MQClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RemotingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MQBrokerException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>至于是要实现全局有序，还是局部有序，在此示例代码中，就取决于 TopicTestOrdered 这个 Topic 的队列数了。</p></li> <li><p>消费者</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MQClientException</span> <span class="token punctuation">{</span>
 
        <span class="token comment">//声明并初始化一个consumer</span>
        <span class="token comment">//需要一个consumer group名字作为构造方法的参数，这里为concurrent_consumer</span>
        <span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">&quot;ordered_consumer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//同样也要设置NameServer地址</span>
        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">&quot;10.1.54.121:9876;10.1.54.122:9876&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//这里设置的是一个consumer的消费策略</span>
        <span class="token comment">//CONSUME_FROM_LAST_OFFSET 默认策略，从该队列最尾开始消费，即跳过历史消息</span>
        <span class="token comment">//CONSUME_FROM_FIRST_OFFSET 从队列最开始开始消费，即历史消息（还储存在broker的）全部消费一遍</span>
        <span class="token comment">//CONSUME_FROM_TIMESTAMP 从某个时间点开始消费，和setConsumeTimestamp()配合使用，默认是半个小时以前</span>
        consumer<span class="token punctuation">.</span><span class="token function">setConsumeFromWhere</span><span class="token punctuation">(</span><span class="token class-name">ConsumeFromWhere</span><span class="token punctuation">.</span>CONSUME_FROM_FIRST_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//设置consumer所订阅的Topic和Tag</span>
        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;TopicTestOrdered&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;TagA || TagC || TagD&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//设置一个Listener，主要进行消息的逻辑处理</span>
        <span class="token comment">//注意这里使用的是MessageListenerOrderly这个接口</span>
        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerOrderly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">ConsumeOrderlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">&gt;</span></span> msgs<span class="token punctuation">,</span> <span class="token class-name">ConsumeOrderlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                 
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; Receive New Messages: &quot;</span> <span class="token operator">+</span> msgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
                <span class="token comment">//返回消费状态</span>
                <span class="token comment">//SUCCESS 消费成功</span>
                <span class="token comment">//SUSPEND_CURRENT_QUEUE_A_MOMENT 消费失败，暂停当前队列的消费</span>
                <span class="token keyword">return</span> <span class="token class-name">ConsumeOrderlyStatus</span><span class="token punctuation">.</span>SUCCESS<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">//调用start()方法启动consumer</span>
        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Consumer Started.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>同一个队列的消息内部采用单线程消费，保证顺序性</p></blockquote></li></ul> <h4 id="_3-顺序消息常见问题"><a href="#_3-顺序消息常见问题" class="header-anchor">#</a> 3）顺序消息常见问题</h4> <ol><li><p>同一条消息是否可以既是顺序消息，又是定时消息和事务消息？</p> <p>不可以。顺序消息、定时消息、事务消息是不同的消息类型，三者是互斥关系，不能叠加在一起使用。</p></li> <li><p>顺序消息支持哪些地域？</p> <p>支持消息队列 RocketMQ 版所有公共云地域和金融云地域。</p></li> <li><p>为什么全局顺序消息性能一般？</p> <p>全局顺序消息是严格按照 FIFO 的消息阻塞原则，即上一条消息没有被成功消费，那么下一条消息会一直被存储到 Topic 队列中。如果想提高全局顺序消息的 TPS，可以升级实例配置，同时消息客户端应用尽量减少处理本地业务逻辑的耗时。</p></li> <li><p>顺序消息支持哪种消息发送方式？</p> <p>顺序消息只支持可靠同步发送方式，不支持异步发送方式，否则将无法严格保证顺序。</p></li> <li><p>顺序消息是否支持集群消费和广播消费？</p> <p>顺序消息暂时仅支持集群消费模式，不支持广播消费模式。</p></li></ol> <h3 id="延时消息"><a href="#延时消息" class="header-anchor">#</a> 延时消息</h3> <p>延时消息，简单来说就是当 producer 将消息发送到 broker 后，会延时一定时间后才投递给 consumer 进行消费。</p> <p>RcoketMQ的延时等级为：1s，5s，10s，30s，1m，2m，3m，4m，5m，6m，7m，8m，9m，10m，20m，30m，1h，2h。level=0，表示不延时。level=1，表示 1 级延时，对应延时 1s。level=2 表示 2 级延时，对应5s，以此类推。</p> <p>这种消息一般适用于消息生产和消费之间有时间窗口要求的场景。比如说我们网购时，下单之后是有一个支付时间，超过这个时间未支付，系统就应该自动关闭该笔订单。那么在订单创建的时候就会就需要发送一条延时消息（延时15分钟）后投递给 consumer，consumer 接收消息后再对订单的支付状态进行判断是否关闭订单。</p> <p>设置延时非常简单，只需要在Message设置对应的延时级别即可：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">&quot;TopicTest&quot;</span><span class="token punctuation">,</span><span class="token comment">// topic</span>
                        <span class="token string">&quot;TagA&quot;</span><span class="token punctuation">,</span><span class="token comment">// tag</span>
                        <span class="token punctuation">(</span><span class="token string">&quot;Hello RocketMQ &quot;</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">RemotingHelper</span><span class="token punctuation">.</span>DEFAULT_CHARSET<span class="token punctuation">)</span><span class="token comment">// body</span>
                <span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 这里设置需要延时的等级即可</span>
                msg<span class="token punctuation">.</span><span class="token function">setDelayTimeLevel</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="批量消息"><a href="#批量消息" class="header-anchor">#</a> 批量消息</h3> <blockquote><p>批量发送消息能显著提高传递小消息的性能。限制是这些批量消息应该有相同的topic，相同的waitStoreMsgOk，而且不能是延时消息。此外，这一批消息的总大小不应超过4MB, 如果超过4MB，这时候最好把消息进行分割。</p></blockquote> <h4 id="_1-发送批量消息"><a href="#_1-发送批量消息" class="header-anchor">#</a> 1）发送批量消息</h4> <p>如果你每次只发送不超过 4MB 的消息, 则可以使用批量处理，样例如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MQClientException</span><span class="token punctuation">,</span> <span class="token class-name">RemotingException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">MQBrokerException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1.创建消息生产者producer，并制定生产者组名</span>
        <span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">&quot;group1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2.指定NameServer地址</span>
        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">&quot;localhost:9876&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3.启动producer</span>
        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">&gt;</span></span> msgs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4.创建消息对象，指定主题Topic、Tag和消息体</span>
        <span class="token comment">/*
        参数1：消息主题Topic
        参数2：消息Tag
        参数3：消息内容
         */</span>
        <span class="token class-name">Message</span> msg1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">&quot;batchTopic&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;tag1&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Message</span> msg2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">&quot;batchTopic&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;tag1&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Message</span> msg3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">&quot;batchTopic&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;tag1&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        msgs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>msg1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        msgs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>msg2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        msgs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>msg3<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 5.发送消息结果包含  发送状态  消息id 消息接收队列id等</span>
        <span class="token class-name">SendResult</span> result <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;发送结果&quot;</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token comment">// 线程睡眠1秒</span>
        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 6.关闭生产者producer</span>
        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_2-消费者消费消息"><a href="#_2-消费者消费消息" class="header-anchor">#</a> 2）消费者消费消息</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MQClientException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1.创建消费者Consumer，制定消费者组名</span>
        <span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">&quot;group1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2.指定Nameserver地址</span>
        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">&quot;localhost:9876&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3.订阅主题Topic和Tag</span>
        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;batchTopic&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 消费模式：默认是负载均衡模式，还有一种是广播模式</span>
<span class="token comment">//        consumer.setMessageModel(MessageModel.BROADCASTING);</span>
        <span class="token comment">// 4.设置回调函数，处理消息</span>
        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//接收消息内容</span>
            <span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token class-name">ConsumeConcurrentlyContext</span> consumeConcurrentlyContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">MessageExt</span> messageExt <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>messageExt<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 5.启动消费者consumer</span>
        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;消费者启动&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="事务消息"><a href="#事务消息" class="header-anchor">#</a> 事务消息</h3> <h4 id="_1-背景"><a href="#_1-背景" class="header-anchor">#</a> 1）背景</h4> <p>MQ组件是系统架构里必不可少的一门利器，设计层面可以降低系统耦合度，高并发场景又可以起到削峰填谷的作用，从单体应用到集群部署方案，再到现在的微服务架构，MQ凭借其优秀的性能和高可靠性，得到了广泛认可。</p> <p>随着数据量增多，系统压力变大，开始出现这种现象：数据库已经更新了，但消息没发出来，或者消息先发了，但后来数据库更新失败了，结果研发童鞋各种数据修复，这种生产问题出现的概率不大，但让人很郁闷。这个其实就是数据库事务与MQ消息的一致性问题，简单来讲，数据库的事务跟普通MQ消息发送无法和数据库事务绑定在一起，例如上面提及的两种问题场景：</p> <ol><li>数据库事务提交后发送MQ消息；</li> <li>MQ消息先发，然后再提交数据库事务。</li></ol> <p>场景1的问题是数据库事务可能刚刚提交，服务器就宕机了，MQ消息没发出去，场景2的问题就是MQ消息发送出去了，但数据库事务提交失败，又没办法追加已经发出去的MQ消息，结果导致数据没更新，下游已经收到消息，最终事务出现不一致的情况。</p> <h4 id="_2-事务的引出"><a href="#_2-事务的引出" class="header-anchor">#</a> 2）事务的引出</h4> <p>我们以微服务架构的购物场景为例，参照一下RocketMQ官方的例子，用户A发起订单，支付100块钱操作完成后，能得到100积分，账户服务和会员服务是两个独立的微服务模块，有各自的数据库，按照上文提及的问题可能性，将会出现这些情况：</p> <ul><li>如果先扣款，再发消息，可能钱刚扣完，宕机了，消息没发出去，结果积分没增加。</li> <li>如果先发消息，再扣款，可能积分增加了，但钱没扣掉，白送了100积分给人家。</li> <li>钱正常扣了，消息也发送成功了，但会员服务实例消费消息出现问题，结果积分没增加。</li></ul> <p><img src="/study/assets/img/1834889-20191019084521916-111869438.b0d0539d.png" alt="购物场景MQ通信案例"></p> <p>由此引出的是数据库事务与MQ消息的事务一致性问题，rocketmq事务消息解决的问题：解决本地事务执行与消息发送的原子性问题。这里界限一定要明白，是确保MQ生产端正确无误地将消息发送出来，没有多发，也不会漏发。但至于发送后消费端有没有正常的消费掉（如上面提及的第三种情况，钱正常扣了，消息也发了，但下游消费出问题导致积分不对），这种异常场景将由MQ消息消费失败重试机制来保证，不在此次的讨论范围内。</p> <h4 id="_3-rocketmq事务消息设计思路"><a href="#_3-rocketmq事务消息设计思路" class="header-anchor">#</a> 3）RocketMQ事务消息设计思路</h4> <p>根据CAP理论，RocketMQ事务消息通过异步确保方式，保证事务的最终一致性。设计流程上借鉴两阶段提交理论，流程图如下：</p> <p><img src="/study/assets/img/1834889-20191019084524981-1962615399.66b6ae1d.png" alt="RocetMQ事务消息设计图"></p> <ol><li>应用模块遇到要发送事务消息的场景时，先发送 half消息 给MQ。</li> <li>Half消息发送成功后，应用模块执行数据库事务（本地事务）,如果写入失败，此时Half消息对业务不可见，本地逻辑不执行）</li> <li>根据数据库事务执行的结果，再返回Commit或Rollback给MQ。</li> <li>如果是Commit，MQ把消息下发给Consumer端，如果是Rollback，直接删掉prepare消息。</li> <li>第3步的执行结果如果没响应，或是超时的，启动定时任务回查事务状态（最多重试15次，超过了默认丢弃此消息），处理结果同第4步。</li> <li>MQ消费的成功机制由MQ自己保证。</li></ol> <h4 id="_4-事务消息状态"><a href="#_4-事务消息状态" class="header-anchor">#</a> 4）事务消息状态</h4> <p>事务消息共有三种状态：提交状态、回滚状态、中间状态</p> <ul><li>TransactionStatus.CommitTransaction: 提交状态，它允许消费者消费此消息</li> <li>TransactionStatus.RollbackTransaction: 回滚状态，它代表该消息被删除，不允许被消费</li> <li>TransactionStatus.Unknown：中间状态，它代表需要检查消息队列来确定状态</li></ul> <p>示例代码：</p> <ul><li><p>生产者</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SyncProducer</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>

        <span class="token comment">// 创建事务消息生产者对象 producer, 并指定生产者组</span>
        <span class="token class-name">TransactionMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransactionMQProducer</span><span class="token punctuation">(</span><span class="token string">&quot;transaction_group&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 指定 NameServer 地址</span>
        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">&quot;192.168.44.139:9876; 192.168.44.140:9876&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 添加事务监听器</span>
        producer<span class="token punctuation">.</span><span class="token function">setTransactionListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TransactionListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">/**
             * 在该方法中执行本地事务
             * @param msg
             * @param arg
             * @return
             */</span>
            <span class="token keyword">public</span> <span class="token class-name">LocalTransactionState</span> <span class="token function">executeLocalTransaction</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;TAGA&quot;</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">getTags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>COMMIT_MESSAGE<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;TAGB&quot;</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">getTags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>ROLLBACK_MESSAGE<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>UNKNOW<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token comment">/**
             * 该方法是 MQ 进行事务消息状态的回查
             * @param msg
             * @return
             */</span>
            <span class="token keyword">public</span> <span class="token class-name">LocalTransactionState</span> <span class="token function">checkLocalTransaction</span><span class="token punctuation">(</span><span class="token class-name">MessageExt</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;消息的TAG：&quot;</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span><span class="token function">getTags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>COMMIT_MESSAGE<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 启动 producer</span>
        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 发送消息</span>
        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tags <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;TAGA&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;TAGB&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;TABC&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">&quot;TransactionTopic&quot;</span><span class="token punctuation">,</span> tags<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">SendResult</span> send <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">sendMessageInTransaction</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;发送结果：&quot;</span><span class="token operator">+</span>send<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 关闭生产者 producer</span>
        <span class="token comment">//producer.shutdown();</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;发送完毕&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>消费者</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1.创建消费者Consumer，制定消费者组名</span>
        <span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">&quot;sync_group5&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2.指定Nameserver地址</span>
        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">&quot;192.168.44.139:9876; 192.168.44.140:9876&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3.订阅主题Topic和Tag</span>
        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;TransactionTopic&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 消费模式：默认是负载均衡模式，还有一种是广播模式</span>
        consumer<span class="token punctuation">.</span><span class="token function">setMessageModel</span><span class="token punctuation">(</span><span class="token class-name">MessageModel</span><span class="token punctuation">.</span>CLUSTERING<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4.设置回调函数，处理消息</span>
        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//接收消息内容</span>
            <span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token class-name">ConsumeConcurrentlyContext</span> consumeConcurrentlyContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">MessageExt</span> messageExt <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>messageExt<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 5.启动消费者consumer</span>
        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;生产者启动&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最终 TAGA 和 TAGC TAGC 消费成功。</p></li></ul> <h2 id="高级特性"><a href="#高级特性" class="header-anchor">#</a> 高级特性</h2> <h3 id="消息过滤"><a href="#消息过滤" class="header-anchor">#</a> 消息过滤</h3> <p>说到消息过滤，就不得不说到 tag。没错，就是我们之前在专业术语中提到过的 tag。也称为消息标签，用来标记 Topic 下的不同用途的消息。</p> <p>在 RocketMQ 中消费者是可以按照 Tag 对消息进行过滤。举个电商交易场景的例子，用户下完订单之后，在后台会产生一系列的消息，比如说订单消息、支付消息和物流消息。</p> <p>假设这些消息都发送到 Topic 为 Trade 中，同时用 tag 为 order 来标记订单消息，用 tag 为 pay 来标记支付消息，用 tag 为 logistics 来标记物流消息。需要支付消息的支付系统（相当于一个 consumer）订阅 Trade 中 tag 为 pay 的消息，此时，broker 则只会把 tag 为 pay 的消息投递给支付系统。</p> <p>而如果是一个实时计算系统，它可能需要接收所有和交易相关的消息，那么只要它订阅 Trade 中 tag 为 order、pay、logistics 的消息，broker 就会把带有这些 tag 的消息投递给实时计算系统。</p> <p><strong>适用场景</strong></p> <p>您可能会有这样的疑问：到底什么时候该用 Topic，什么时候该用 Tag？</p> <p>建议您从以下几个方面进行判断：</p> <ul><li><p>消息类型是否一致：如普通消息、事务消息、定时（延时）消息、顺序消息，不同的消息类型使用不同的 Topic，无法通过 Tag 进行区分。</p></li> <li><p>业务是否相关联：没有直接关联的消息，如淘宝交易消息，京东物流消息使用不同的 Topic 进行区分；而同样是天猫交易消息，电器类订单、女装类订单、化妆品类订单的消息可以用 Tag 进行区分。</p></li> <li><p>消息优先级是否一致：如同样是物流消息，盒马必须小时内送达，天猫超市 24 小时内送达，淘宝物流则相对会慢一些，不同优先级的消息用不同的 Topic 进行区分。</p></li> <li><p>消息量级是否相当：有些业务消息虽然量小但是实时性要求高，如果跟某些万亿量级的消息使用同一个 Topic，则有可能会因为过长的等待时间而“饿死”，此时需要将不同量级的消息进行拆分，使用不同的 Topic。</p></li></ul> <p>总的来说，针对消息分类，您可以选择创建多个 Topic，或者在同一个 Topic 下创建多个 Tag。但通常情况下，不同的 Topic 之间的消息没有必然的联系，而 Tag 则用来区分同一个 Topic 下相互关联的消息，例如全集和子集的关系、流程先后的关系。</p> <h4 id="_1-tag过滤"><a href="#_1-tag过滤" class="header-anchor">#</a> 1）Tag过滤</h4> <blockquote><p>发送消息时，每条消息必须指明 Tag</p></blockquote> <ul><li><p>订阅所有 Tag</p> <p>消费者如需订阅某 Topic 下所有类型的消息，Tag 用符号 * 表示：</p> <div class="language-java extra-class"><pre class="language-java"><code>    consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;MQ_TOPIC&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token class-name">Action</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">ConsumeContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMsgID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token class-name">Action<span class="token punctuation">.</span>CommitMessage</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                
</code></pre></div></li> <li><p>订阅单个 Tag</p> <p>消费者如需订阅某 Topic 下某一种类型的消息，请明确标明 Tag：</p> <div class="language-java extra-class"><pre class="language-java"><code>    consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;MQ_TOPIC&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;TagA&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token class-name">Action</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">ConsumeContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMsgID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token class-name">Action<span class="token punctuation">.</span>CommitMessage</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                
</code></pre></div></li> <li><p>订阅多个 Tag</p> <p>消费者如需订阅某 Topic 下多种类型的消息，请在多个 Tag 之间用 || 分隔：</p> <div class="language-java extra-class"><pre class="language-java"><code>    consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;MQ_TOPIC&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;TagA||TagB&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token class-name">Action</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">ConsumeContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMsgID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token class-name">Action<span class="token punctuation">.</span>CommitMessage</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                
</code></pre></div></li> <li><p>错误示例</p> <p>同一个消费者多次订阅某个 Topic 下的 Tag，以最后一次订阅的 Tag 为准：</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token comment">//如下错误代码中，Consumer 只能订阅到 MQ_TOPIC 下 TagB 的消息，而不能订阅 TagA 的消息。</span>
    consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;MQ_TOPIC&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;TagA&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token class-name">Action</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">ConsumeContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMsgID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token class-name">Action<span class="token punctuation">.</span>CommitMessage</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;MQ_TOPIC&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;TagB&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token class-name">Action</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">ConsumeContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMsgID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token class-name">Action<span class="token punctuation">.</span>CommitMessage</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
</code></pre></div></li></ul> <h4 id="_2-sql-过滤"><a href="#_2-sql-过滤" class="header-anchor">#</a> 2）SQL 过滤</h4> <p>要实现SQL过滤，需要先修改消息队列的配置文件</p> <p>在broker的配置文件 添加enablePropertyFilter=true</p> <ul><li>生产者</li></ul> <div class="language-java extra-class"><pre class="language-java"><code>ublic <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>

        <span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">&quot;SQLFilter_test_group&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">&quot;172.16.17.20:9876&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tags <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">&quot;TagA&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;TagB&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;TagC&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">&quot;SqlFilterTest&quot;</span><span class="token punctuation">,</span>
                tags<span class="token punctuation">[</span>i <span class="token operator">%</span> tags<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">,</span>
                <span class="token punctuation">(</span><span class="token string">&quot;Hello RocketMQ &quot;</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">RemotingHelper</span><span class="token punctuation">.</span>DEFAULT_CHARSET<span class="token punctuation">)</span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
            msg<span class="token punctuation">.</span><span class="token function">putUserProperty</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s%n&quot;</span><span class="token punctuation">,</span> sendResult<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>生成消息的时候，使用<code>msg.putUserProperty(&quot;a&quot;, String.valueOf(i));</code>设置一个属性，这个属性在消费的时候会拿来写SQL语句，详情见下方消费示例，其他和普通消息的发送没有区别。</p></blockquote> <ul><li>消费者</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>

        <span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">&quot;sql92_consumer_test_&quot;</span><span class="token operator">+</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">&quot;172.16.17.20:9876&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Don't forget to set enablePropertyFilter=true in broker</span>
        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">&quot;SqlFilterTest&quot;</span><span class="token punctuation">,</span>
            <span class="token class-name">MessageSelector</span><span class="token punctuation">.</span><span class="token function">bySql</span><span class="token punctuation">(</span><span class="token string">&quot;(TAGS is not null and TAGS in ('TagA', 'TagB'))&quot;</span> <span class="token operator">+</span>
                <span class="token string">&quot;and (a is not null and a between 0 and 3)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>msgs<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s Receive New Messages: %s %n&quot;</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Consumer Started.%n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>消息订阅的时候使用了<code>MessageSelector.bySql();</code>表明使用SQL92的过滤模式，然后传入的字符串是符合SQL92语法的语句。</p> <p>共2个条件组成SQL表达式进行消息的过滤:</p> <ol><li><p><code>TAGS !=null</code>,且<code>TAGS =='TagA' || TAGS=='TagB'</code>。</p></li> <li><p>a!=null<code>，且</code>a≥0 &amp;&amp; a≤3<code>。</code></p></li></ol> <p>为了兼容tag过滤，在SQL92过滤中，使用TAGS替代tag,然后a是消息生产时<code>msg.putUserProperty(&quot;a&quot;, String.valueOf(i));</code>设置的属性。</p></blockquote> <h4 id="_3-总结"><a href="#_3-总结" class="header-anchor">#</a> 3）总结</h4> <p>在实际使用中，消息过滤可以帮助我们只消费我们所需要的消息，这是在broker端就帮我们处理好的，大大减少了在 consumer 端的消息过滤处理，一方面减少了代码量，另一方面更减少了不必要消息的网络传输消耗。</p> <h3 id="订阅关系一致性"><a href="#订阅关系一致性" class="header-anchor">#</a> 订阅关系一致性</h3> <p>讲完了消息过滤，我们接着讲讲什么是订阅关系一致性呢？其实在讲 RocketMQ 消费模式的时候提到过，除了使用同一个 group name，订阅的 tag 也必须是一样的，只有符合这两个条件的 consumer 实例才能组成 consumer 集群。这里所说的其实就是订阅关系一致性。在 RocketMQ 中，订阅关系由 Topic和 Tag 组成，因此要保证订阅关系一致性，就必须同时保证这两点：</p> <ol><li><strong>订阅的 Topic 必须一致</strong></li> <li><strong>订阅的 Topic 中的 tag 必须一致</strong></li></ol> <p>保证订阅关系一致性是非常重要的，一旦订阅关系不一致，消息消费的逻辑就会混乱，甚至导致消息丢失，这对于大部分业务场景来说都是不允许的，甚至是致命的。在实际使用中，切记同一个消费者集群内的所有消费者实例务必要保证订阅关系的一致性。</p> <p><img src="/study/assets/img/20190612161314703.314509b4.png" alt="img"></p> <p>我们用具体的例子来解释一下，如图 1 所示，消费者集群中有 3 个 consumer 实例，分别为 C1、C2、C3，各自订阅的 topic 和 tag 各不相同。首先 C1 和 C2 都订阅 TopicA，满足了订阅关系一致性的第一点，但是 C1 订阅的是 TopicA 的 Tag1，而 C2 订阅的是 TopicA 的 Tag2，不满足订阅关系一致性的第二点，所以 C1、C2 不满足订阅关系一致性。而 C3 订阅的 Topic 和 Tag 都与 C1 和 C2不一样，同样也不满足订阅关系一致性。</p> <p><img src="/study/assets/img/20190612161326744.61c2a9f3.png" alt="img"></p> <p>在图 2 中，消费者集群中有 3 个 consumer 实例，分别为 C1、C2、C3，都是订阅 TopicA 下的 Tag1 和 Tag2，满足了订阅关系一致性的两点要求，所以满足了订阅关系一致性。</p> <p><img src="/study/assets/img/20190612161336504.56cbf58e.png" alt="img"></p> <p>如图 3 所示，一个 consumer 也可以订阅多个 Topic，同时也必须保证该 consumer 集群里的多个消费者实例的订阅关系一致性，才不会造成不必要的麻烦。</p> <p>总结：</p> <p>订阅消息一致性则保证了同一个消费者集群中 consumer 实例的正常运行，避免消息逻辑的混乱和消息的丢失。所以在实际使用中，在 producer 端要做好消息的分类，便于 consumer 可以使用 tag 进行消息的准确订阅，而在 consumer 端，则要保证订阅关系一致性。</p> <h3 id="消息重试"><a href="#消息重试" class="header-anchor">#</a> 消息重试</h3> <p>首先明确之前说过的，消息重试<strong>只针对集群消费模式</strong>，广播消费没有消息重试的特性，消费失败之后，只会继续消费下一条消息。这也是为什么我们一再强调，推荐大家使用集群消费模式，其消息重试的特性能给开发者带来极大的方便。</p> <p>那么什么是消息重试呢？简单来说，就是当消费者消费消息失败后，broker 会重新投递该消息，直到消费成功。在 RocketMQ 中，当消费者使用集群消费模式时，消费者接收到消息并进行相应的逻辑处理之后，最后都要返回一个状态值给 broker。这样 broker 才知道是否消费成功，需不需要重新投递消息。也就是说，我们可以通过设置返回的状态值来告诉 broker 是否重新投递消息。</p> <p>到这里，可能大家会有一个疑问，那如果这条消息本身就是一条脏数据，就算你消费 100 次也不会消费成功，难道还是一直去重试嘛？其实 RocketMQ 并不会无限制地重试下去，默认每条消息最多重试 16 次，而每次重试的间隔时间如下表所示：</p> <table><thead><tr><th style="text-align:left;">第几次重试</th> <th style="text-align:left;">每次重试间隔时间</th></tr></thead> <tbody><tr><td style="text-align:left;">1</td> <td style="text-align:left;">10 秒</td></tr> <tr><td style="text-align:left;">2</td> <td style="text-align:left;">30 秒</td></tr> <tr><td style="text-align:left;">3</td> <td style="text-align:left;">1 分钟</td></tr> <tr><td style="text-align:left;">4</td> <td style="text-align:left;">2 分钟</td></tr> <tr><td style="text-align:left;">5</td> <td style="text-align:left;">3 分钟</td></tr> <tr><td style="text-align:left;">6</td> <td style="text-align:left;">4 分钟</td></tr> <tr><td style="text-align:left;">7</td> <td style="text-align:left;">5 分钟</td></tr> <tr><td style="text-align:left;">8</td> <td style="text-align:left;">6 分钟</td></tr> <tr><td style="text-align:left;">9</td> <td style="text-align:left;">7 分钟</td></tr> <tr><td style="text-align:left;">10</td> <td style="text-align:left;">8 分钟</td></tr> <tr><td style="text-align:left;">11</td> <td style="text-align:left;">9 分钟</td></tr> <tr><td style="text-align:left;">12</td> <td style="text-align:left;">10 分钟</td></tr> <tr><td style="text-align:left;">13</td> <td style="text-align:left;">20 分钟</td></tr> <tr><td style="text-align:left;">14</td> <td style="text-align:left;">30 分钟</td></tr> <tr><td style="text-align:left;">15</td> <td style="text-align:left;">1 小时</td></tr> <tr><td style="text-align:left;">16</td> <td style="text-align:left;">2 小时</td></tr></tbody></table> <p>那么如果消息重试 16 次之后还是消费失败怎么办呢？那么消息就不会再投递给消费者，而是将消息放到相对应的死信队列中。这时候我们就需要对死信队列的消息做一些人工补偿处理，因为这些消息可能本身就有问题，也有可能和消费逻辑调用的服务有关等，所以需要人工判断之后再进行处理。</p> <p>到这里不知道大家有没有一个疑问，那就是什么样的情况才叫消费失败呢？可以分为 3 种情况：</p> <ol><li><strong>返回 ConsumeConcurrentlyStatus.RECONSUME_LATER</strong></li> <li><strong>返回 null</strong></li> <li><strong>抛出异常</strong></li></ol> <p>前两种情况都比较好理解，就是前面说过的设置状态值，也就是说，只需要消费者返回 ConsumeConcurrentlyStatus.RECONSUME_LATER 或者 null，就相当于告诉 broker 说，这条消息我消费失败了，你给我重新投递一次。而对于抛出异常这种情况，只要在你处理消费逻辑的地方抛出了异常,那么 broker 也重新投递这条消息。注意一点，如果是被捕获的异常，则不会进行消息重试。</p> <h3 id="消息幂等"><a href="#消息幂等" class="header-anchor">#</a> 消息幂等</h3> <p>首先什么是消费幂等呢？简单来说就是对于一条消息的处理结果，不管这条消息被处理多少次，最终的结果都一样。比如说，你收到一条消息是要更新一个商品的价格为 6.8 元，那么当这条消息执行 1 次，还是执行 100 次，最终在数据库里的该商品价格就是 6.8 元，这就是所谓的幂等。 那么为什么消费需要幂等呢？因为在实际使用中，尤其在网络不稳定的情况下，RocketMQ 的消息有可能会出现重复，包括两种情况：</p> <ol><li><strong>发送时消息重复</strong></li> <li><strong>投递时消息重复</strong></li></ol> <p>第一种情况是生产者发送消息的场景，消息已成功发送到 broker ，但是此时可能发生网络闪断或者生产者宕机了，导致 broker 发回的响应失败。这时候生产者由于没有收到响应，认为消息发送失败，于是尝试再次发送消息给 broker。这样一来，broker 就会再收到一条一摸一样内容的消息，最终造成了消费者也收到两条内容一摸一样的消息。</p> <p>第二种情况是消费者消费消息的场景，消息已投递到消费者并完成消费逻辑处理，当消费者给 broker 反馈消费状态时可能发生网络闪断。broker 收不到消费者的消费状态，为了保证至少消费一次的语义，broker 将在网络恢复后再次尝试投递之前已经被处理过的消息，最终造成消费者收到两条内容一摸一样的消息。</p> <p>当然对于一些允许消息重复的场景，大可以不必关心消费幂等。但是对于那些不允许消息重复的业务场景来说，处理建议就是通过业务上的唯一标识来作为幂等处理的依据。</p> <p><strong>总结：</strong></p> <p>消息重试，保证了消费消息的容错性，即使消费失败，也不需要开发者自己去编写代码来做补偿，大大提高了开发效率，同时也是 RocketMQ 相较于其他 MQ 的一个非常好的特性。而消费幂等主要是针对那些不允许消息重复的场景，应该说大部分 MQ 都需要幂等处理，这属于代码逻辑或者说业务上的需要，最好的处理方式就是前面所说的根据业务上唯一标识来作为幂等处理的依据。</p> <h2 id="高级功能"><a href="#高级功能" class="header-anchor">#</a> 高级功能</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/study/xiao-xi-dui-lie/kafka/kafka.html" class="prev">
        Kafka
      </a></span> <span class="next"><a href="/study/xiao-xi-dui-lie/rocketmq/02gao-ji-te-xing.html">
        02-高级特性
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/study/assets/js/app.dc60e210.js" defer></script><script src="/study/assets/js/6.fceef279.js" defer></script><script src="/study/assets/js/10.7ed69d34.js" defer></script>
  </body>
</html>
